{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>TowerOS is an operating system for combining multiple, independent computers into a single high-assurance system for high-value targets and paranoid individuals. TowerOS is an example of a converged multi-level secure (MLS) computing system, similar to Qubes OS; but whereas Qubes OS takes a single computer and splits it into multiple security domains, TowerOS does the reverse\u2014each security domain is relegated to a separate, dedicated host (e.g. a Raspberry Pi), and the user accesses their applications from a thin client (e.g. a laptop) over a LAN using standard network protocols (namely, SSH and NX), with strict firewall rules governing all network communication. The different security domains are by default completely independent, and all communication across security boundaries is under the direct control of the user.</p> <p>In contrast to existing designs, Tower offers theoretically greater security guarantees, better usability, and more flexibility. The downside is that you need multiple computers to make it work. However, with the development of cheap, powerful and small single-board computers (SBCs), it's now quite practical to carry half a dozen computers with you wherever you go. For a more formal description of the design of TowerOS, including a detailed comparison with Qubes OS, please refer to the whitepaper.</p> <p>TowerOS is completely open-source and freely licensed (under the Apache License 2.0). All TowerOS source code, as well the sources used to generate this documentation, is hosted on the TowerOS GitHub repository.</p> <p></p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#set-up-development-environment","title":"Set Up Development Environment","text":""},{"location":"development/#connect-to-internet","title":"Connect to internet","text":"<p>To connect the thin client to the Internet you must:</p> <ol> <li>Provision a <code>router</code>.</li> <li> <p>Set the gateway on the thin client to <code>192.168.2.1</code> (the router's IP address):</p> <p>The file <code>/etc/network/interfaces</code> must contain the following:</p> <pre><code>auto lo\niface lo inet loopback\nauto eth0\niface eth0 inet static\n    address 192.168.2.100/24\n    gateway 192.168.2.1\nauto eth1\niface eth1 inet static\n    address 192.168.3.100/24\n</code></pre> </li> <li> <p>Set the DNS server on the thin client:</p> <p>The file <code>/etc/resolv.conf</code> must contain the following:</p> <pre><code>nameserver 8.8.8.8\nnameserver 8.8.4.4\n</code></pre> </li> <li> <p>Restart the network with: <code>[thinclient]$ sudo rc-service networking restart</code></p> </li> </ol>"},{"location":"development/#configure-git-and-download-github-repository","title":"Configure Git and download Github repository","text":"<p>Configure <code>git</code>, download Github repository in <code>~/towercomputers/toweros</code> and install <code>hatch</code> with:</p> <pre><code>[thinclient]$ /var/towercomputers/install-dev.sh &lt;git-name&gt; &lt;git-email&gt; &lt;git-private-key-path&gt;\n</code></pre>"},{"location":"development/#use-tower-cli-with-hatch","title":"Use <code>tower-cli</code> with <code>hatch</code>","text":"<pre><code>[thinclient]$ cd ~/towercomputers/toweros/tower-cli\n[thinclient]$ hatch run tower --help\n</code></pre>"},{"location":"development/#build-toweros-images","title":"Build TowerOS images","text":"<p>Connect to internet and download Github repository as explained in the first paragraph above.</p>"},{"location":"development/#toweros-host","title":"TowerOS Host","text":"<pre><code>[thinclient]$ cd ~/towercomputers/toweros/tower-build-cli\n[thinclient]$ ./tower-build host\n</code></pre> <p>This will generate a TowerOS-Host image file compressed with xz in <code>~/.cache/tower/builds/</code>. Images in this folder will be used by default by the <code>provision</code> command (if the <code>--image</code> flag is not provided).</p>"},{"location":"development/#toweros-thin-client","title":"TowerOS Thin Client","text":"<pre><code>[thinclient]$ ./tower-build thinclient\n</code></pre> <p>This will generate an ISO image in <code>~/.cache/tower/builds/</code>. A TowerOS Host image is embedded in the TowerOS ThinClient image. If a TowerOS Host image is present in the <code>~/.cache/tower/builds/</code> folder, it is used. Otherwise a new image is automatically generated.</p>"},{"location":"development/#with-docker","title":"With Docker","text":"<p>Build the Docker image with:</p> <pre><code>[thinclient]$ git clone git@github.com:towercomputers/toweros.git\n[thinclient]$ cd toweros/tower-build-cli\n[thinclient]$ docker build -t build-tower-image:latest -f ./Dockerfile ../\n</code></pre> <p>Then build the TowerOS image inside a Docker container:</p> <pre><code>[thinclient]$ docker run --name towerbuilder --user tower --privileged -v /dev:/dev build-tower-image thinclient\n</code></pre> <p>Retrieve that image from the container:</p> <pre><code>[thinclient]$ docker cp towerbuilder:/home/tower/.cache/tower/builds/toweros-thinclient-0.0.1-20230513171731-x86_64.iso ./\n</code></pre> <p>Finally delete the container with:</p> <pre><code>[thinclient]$ docker rm towerbuilder\n</code></pre> <p>Note: With the ARM64 architecture, you must use <code>buildx</code> and a cross-platform emulator like <code>tonistiigi/binfmt</code>.</p> <pre><code>[thinclient]$ docker buildx create --use\n[thinclient]$ docker buildx build -t build-tower-image:latest --platform=linux/amd64 --output type=docker -f ./Dockerfile ../\n[thinclient]$ docker run --privileged --rm tonistiigi/binfmt --install all\n[thinclient]$ docker run --platform=linux/amd64 --name towerbuilder --user tower --privileged -v /dev:/dev \\\n              build-tower-image thinclient\n</code></pre>"},{"location":"development/#build-your-own-custom-thin-client-linux","title":"Build your own custom Thin Client (Linux)","text":""},{"location":"development/#install-dependencies","title":"Install Dependencies","text":"<pre><code>[thinclient]$ apk add alpine-base coreutils python3 py3-pip py3-rich sudo openssh dhcpcd avahi \\\n      avahi-tools wpa_supplicant rsync git iptables rsync lsblk perl-utils xz \\\n      musl-locales e2fsprogs-extra nx-libs xsetroot mcookie parted lsscsi figlet \\\n      alpine-sdk build-base apk-tools acct acct-openrc alpine-conf sfdisk busybox \\\n      fakeroot syslinux xorriso squashfs-tools mtools dosfstools grub-efi abuild \\\n      agetty runuser nano vim net-tools losetup xorg-server xf86-input-libinput \\\n      xinit udev xfce4 xfce4-terminal xfce4-screensaver adw-gtk3 \\\n      adwaita-xfce-icon-theme setxkbmap\n</code></pre>"},{"location":"development/#enable-basic-services","title":"Enable Basic Services","text":"<p>If necessary, enable IPv4 with:</p> <pre><code>[thinclient]$ sed -i 's/noipv4ll/#noipv4ll/' /etc/dhcpcd.conf\n</code></pre> <p>then</p> <pre><code>[thinclient]$ rc-update add dhcpcd\n[thinclient]$ rc-update add avahi-daemon\n[thinclient]$ rc-update add iptables\n[thinclient]$ rc-update add networking\n[thinclient]$ rc-update add wpa_supplicant boot\n[thinclient]$ rc-update add dbus\n</code></pre> <p>Important: Make sure you are connected to the switch and check that your first wired interface (starting with the letter <code>e</code>) has an assigned IP.</p>"},{"location":"development/#update-etcsudoers-and-groups","title":"Update <code>/etc/sudoers</code> and groups","text":"<p>The <code>toweros</code> software assumes that the current user has full <code>sudo</code> access with no password. (Please refer to our threat model.) Check if <code>/etc/sudoers</code> contains the following line:</p> <pre><code>&lt;your_username&gt; ALL=(ALL) NOPASSWD: ALL\n</code></pre> <p>To build an image with <code>./tower-build</code>, you first need to add the current user in the <code>abuild</code> group:</p> <pre><code>[thinclient]$ addgroup &lt;you_username&gt; abuild\n</code></pre>"},{"location":"development/#install-tower-cli","title":"Install <code>tower-cli</code>","text":"<p>Update <code>pip</code> to the latest version:</p> <pre><code>[thinclient]$ python3 -m pip install --upgrade pip\n</code></pre> <p>Install the <code>tower</code> CLI with <code>pip</code>:</p> <pre><code>[thinclient]$ python3 -m pip install \"tower-cli @ git+https://github.com/towercomputers/toweros.git#subdirectory=tower-cli\"\n</code></pre>"},{"location":"development/#manually-qa-toweros","title":"Manually QA TowerOS","text":""},{"location":"development/#toweros-thinclient-installation","title":"TowerOS-ThinClient Installation","text":"<ul> <li>The USB key containing the <code>boot</code> partition must be inserted into the thinclient to boot.</li> <li>Secure Boot must be active if the option was selected during installation.</li> <li>A welcome message should indicate the location of the documentation.</li> <li>The username chosen during installation is correctly created with the chosen password.</li> <li>The keyboard and timezone are correctly configured.</li> <li> <p>The <code>swap</code> partition must be 8Gb, the <code>home</code> partition must occupy 20% of the rest, and the <code>root</code> partition the remaining space. All these partitions must be encrypted. To check, <code>lsblk</code> should display something like this:</p> <pre><code>NAME           MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS\nsda              8:0    0 232.9G  0 disk  \n\u2514\u2500sda1           8:1    0 232.9G  0 part  \n  \u2514\u2500lvmcrypt   253:0    0 232.9G  0 crypt \n    \u251c\u2500vg0-swap 253:1    0     8G  0 lvm   \n    \u251c\u2500vg0-home 253:2    0    45G  0 lvm   /home\n    \u2514\u2500vg0-root 253:3    0 179.9G  0 lvm   /\n</code></pre> </li> <li> <p><code>labwc</code> starts automatically after login if the option was chosen during installation.</p> </li> <li>The documentation must be present in the ~/docs folder and can be consulted with the <code>bat</code> tool.</li> <li>The firewall must be correctly configured and activated (<code>sudo rc-service iptables status</code> and <code>iptables -L -v</code>).</li> <li><code>eth0</code> must be configured with IP <code>192.168.2.100</code> and <code>eth0</code> with IP <code>192.168.3.100</code> (check with <code>ip ad</code>).</li> <li>On reboot the MAC of <code>eth0</code> and <code>eth1</code> should not change (check with <code>ip ad</code>).</li> <li><code>labwc</code> and <code>sfwbar</code> should properly start with <code>dbus-launch labwc</code>.</li> <li>The shell prompt must be in the form of <code>[&lt;username&gt;@thinclient &lt;current folder&gt;]$</code>.</li> <li><code>XDG_RUNTIME_DIR</code> must be set (check with <code>echo $XDG_RUNTIME_DIR</code>).</li> <li><code>supercronic</code> service must be started (check with <code>sudo rc-service supercronic status</code>).</li> <li>Wifi and bluetooth must be soft blocked (check with <code>rfkill list</code>).</li> <li>Default user should be able to use sudo without password (check with <code>sudo su</code>).</li> <li>When <code>labwc</code> is started, the screen locker should activate correctly after 5 minutes of inactivity.</li> <li><code>CopyQ</code> must be correctly started (check the presence of the icon in the taskbar).</li> <li>The latest version of <code>tower</code> cli must be installed (check with <code>tower version</code>).</li> </ul>"},{"location":"development/#hosts-provisioning","title":"Hosts provisioning","text":"<ul> <li>The provisioning of the <code>router</code>, an online host and an offline host must work correctly.</li> <li>The USB key containing the <code>boot</code> partition must be inserted into the host to boot.</li> <li><code>tower status</code> should display all hosts with status <code>up</code>.</li> <li>Hosts must be accessible with <code>ssh</code> simply with their name (check with <code>ssh &lt;host&gt;</code>).</li> <li>The default user, keyboard and timezone should be the same as for the thinclient.</li> <li>Online hosts must be connected and offline hosts must not (check with <code>ssh &lt;host&gt; ping www.google.com</code>).</li> <li>The firewall must be correctly configured and activated (<code>ssh &lt;host&gt; sudo rc-service iptables status</code> and <code>ssh &lt;host&gt; iptables -L -v</code>).</li> <li><code>eth0</code> must be configured on the network <code>192.168.2.0/24</code> for online hosts and <code>192.168.3.0/24</code> for offline hosts (check with <code>ip ad</code>).</li> <li>On the <code>router</code> the MAC of <code>wlan0</code> must be different at each startup.</li> <li> <p>The <code>home</code> partition must occupy 20% and the <code>root</code> partition the remaining space. All these partitions must be encrypted. To check, <code>ssh &lt;host&gt; lsblk</code> should display something like this:</p> <pre><code>NAME         MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINTS\nsda            8:0    1 28.7G  0 disk  \n\u2514\u2500sda1         8:1    1  512M  0 part  \nmmcblk0      179:0    0 29.7G  0 disk  \n\u2514\u2500lvmcrypt   254:0    0 29.7G  0 crypt \n  \u251c\u2500vg0-home 254:1    0  5.9G  0 lvm   /home\n  \u2514\u2500vg0-root 254:2    0 23.8G  0 lvm   /\n</code></pre> </li> <li> <p><code>XDG_RUNTIME_DIR</code> must be set (check with <code>ssh &lt;host&gt; echo $XDG_RUNTIME_DIR</code>).</p> </li> <li>The shell prompt must be in the form of <code>[&lt;username&gt;@&lt;host&gt; &lt;current folder&gt;]$</code> and be of different color for each host.</li> <li>Wifi and bluetooth must be soft blocked except wifi in the <code>router</code> (check with <code>ssh &lt;host&gt; rfkill list</code>).</li> <li>Host default user should be able to use sudo without password (check with <code>ssh &lt;host&gt; sudo su</code>).</li> <li>The hosts should appear in the <code>labwc</code> taskbar with a green icon for the 'up' hosts and a red icon for the 'down' hosts (test by turning off one of the hosts)</li> </ul>"},{"location":"development/#execution-and-installation-of-applications","title":"Execution and installation of applications","text":"<p>Once the <code>router</code> is installed:</p> <ul> <li>APK packages must be correctly installed on the hosts with <code>tower install &lt;host&gt; &lt;package&gt;</code> and on the thinclient with <code>tower install thinclient &lt;package&gt;</code>.</li> <li>Once installed, graphical applications should appear in the <code>sfwbar</code> menu with icons.</li> <li>In the menu the applications are classified by host and each host is differentiated by a colored circle.</li> <li>For each host the color of the circle is the same as that of the shell prompt (check with <code>ssh &lt;host&gt;</code>).</li> <li><code>ssh &lt;host&gt;</code> should not display any welcome message.</li> <li>Graphical applications can be launched via the <code>sfwbar</code> menu or terminal with <code>tower &lt;host&gt; run &lt;application&gt;</code>.</li> <li>Copy/paste must be possible between two graphics applications running on different hosts.</li> <li>Online applications must work correctly on online hosts (check for example that it is possible to browse the web with Midori).</li> <li>The <code>tor</code> proxy must be accessible from online hosts (check with <code>ssh web curl --socks5 192.168.2.1:9050 https://check.torproject.org/api/ip</code>).</li> <li>The time on online hosts must be correct (thanks to <code>chronyd</code>).</li> </ul>"},{"location":"development/#toweros-thinclient-upgrade","title":"TowerOS-ThinClient Upgrade","text":"<p>In addition to all the points listed for installing TowerOS-ThinClient:</p> <ul> <li>The new version of <code>tower</code> cli must be installed (check with <code>tower version</code>).</li> <li>All previously installed hosts must be accessible (check with <code>tower status</code>).</li> <li>The <code>sfwbar</code> menu must display all applications previously installed on the hosts.</li> <li>The <code>sfwbar</code> widget indicating the host status must be active.</li> <li>The contents of the home partition must be completely preserved.</li> </ul>"},{"location":"development/#host-upgrade","title":"Host Upgrade","text":"<p>In addition to all the points listed for Hosts provisioning:</p> <ul> <li>The new version of TowerOS-Host must be installed (check with <code>tower status</code>).</li> <li>All applications installed with <code>tower install</code> must be reinstalled.</li> <li>The contents of the host home partition must be completely preserved.</li> </ul>"},{"location":"guides/","title":"Guides","text":""},{"location":"guides/#move-a-file-from-one-host-to-another","title":"Move a file from one host to another","text":"<pre><code>    [thinclient]$ scp -r router:/home/tower/myfile office:/home/tower\n    [thinclient]$ ssh router rm /home/tower/myfile\n</code></pre>"},{"location":"guides/#backup-hosts-with-restic","title":"Backup hosts with <code>restic</code>","text":"<p>It is recommended to reserve one of your hosts, for example <code>storage</code>, to store the backups of all the other hosts there. Here's how, using <code>restic</code>, you can store the backup of an <code>office</code> host on a <code>storage</code> host:</p> <ol> <li> <p>Install restic</p> <pre><code>[thinclient]$ tower install storage restic\n[thinclient]$ tower install office restic\n[thinclient]$ tower install thinclient restic\n</code></pre> </li> <li> <p>Initialize restic repo in each host</p> <pre><code>[thinclient]$ restic -r sftp:storage:backup init\n[thinclient]$ restic -r sftp:office:backup init --from-repo sftp:storage:backup --copy-chunker-params\n</code></pre> <p>Note: <code>--copy-chunker-params</code> is important to ensure deduplication.  See \"Copying snapshots between repositories\" for more options.</p> </li> <li> <p>Backup <code>~/mydata</code> folder in <code>office</code> host</p> <pre><code>[thinclient]$ ssh -t office restic -r backup backup mydata\n</code></pre> </li> <li> <p>Copy <code>office</code> snapshot into <code>storage</code> repo</p> <pre><code>[thinclient]$ restic -r sftp:storage:backup copy --from-repo sftp:office:backup latest\n</code></pre> <p>Note: here <code>restic</code> copies the backup from the <code>office</code> host to the Thin Client, and then copies it to the <code>storage</code> host. You can optionally clear the cache stored on the Thin Client:</p> <pre><code>[thinclient]$ rm -rf ~/.cache/restic\n</code></pre> </li> <li> <p>Restore backup into <code>office</code></p> <pre><code>[thinclient]$ restic -r sftp:office:backup copy --from-repo sftp:storage:backup latest --host office\n[thinclient]$ ssh -t office restic -r backup restore latest --target ~/\n</code></pre> </li> </ol>"},{"location":"guides/#install-pip-package-in-offline-host-using-online-host","title":"Install <code>pip</code> package in offline host using online host","text":"<ol> <li> <p>Install <code>pip</code> in online and offline host</p> <pre><code>[thinclient]$ tower install web python3 py3-pip\n[thinclient]$ tower install office python3 py3-pip\n</code></pre> </li> <li> <p>Download package and dependencies in online host</p> <pre><code>[thinclient]$ ssh web mkdir mypackages\n[thinclient]$ ssh web pip download &lt;package_name&gt; -d mypackages\n</code></pre> </li> <li> <p>Copy package and dependencies to offline host</p> <pre><code>[thinclient]$ scp -r web:mypackages office:\n</code></pre> </li> <li> <p>Install <code>pip</code> package in offline host</p> <pre><code>[thinclient]$ ssh office pip install --no-index --find-links=\"~/mypackages\" &lt;package_name&gt;\n</code></pre> </li> <li> <p>Clean up</p> <pre><code>[thinclient]$ ssh office rm -rf mypackages\n[thinclient]$ ssh web rm -rf mypackages\n</code></pre> </li> </ol>"},{"location":"guides/#install-npm-package-in-offline-host-using-online-host","title":"Install <code>npm</code> package in offline host using online host","text":"<ol> <li> <p>Install <code>npm</code> in online and offline host</p> <pre><code>[thinclient]$ tower install web npm\n[thinclient]$ tower install office npm\n</code></pre> </li> <li> <p>Download package and dependencies in online host</p> <pre><code>[thinclient]$ ssh web 'mkdir mypackages &amp;&amp; cd mypackages &amp;&amp; npm init -y'\n[thinclient]$ ssh web 'cd mypackages &amp;&amp; npm install -B &lt;package_name&gt; &amp;&amp; npm pack'\n</code></pre> </li> <li> <p>Copy package and dependencies to offline host</p> <pre><code>[thinclient]$ scp -r web:mypackages/mypackages-1.0.0.tgz office:\n</code></pre> </li> <li> <p>Install <code>npm</code> package in offline host</p> <pre><code>[thinclient]$ ssh office tar -xvzf mypackages-1.0.0.tgz\n[thinclient]$ ssh office 'sudo npm install -g package/node_modules/*/'\n</code></pre> </li> <li> <p>Clean up</p> <pre><code>[thinclient]$ ssh office rm -rf mypackages-1.0.0.tgz package\n[thinclient]$ ssh web rm -rf mypackages\n</code></pre> </li> </ol>"},{"location":"hardware/","title":"Hardware","text":"<p>TowerOS is designed to run on a thin client device and several hosts connected via one or two unmanaged Ethernet switches. Two switches are necessary if the user would like to have offline as well as online hosts.</p>"},{"location":"hardware/#thin-client-hardware","title":"Thin Client Hardware","text":"<p>The thin client is typically a laptop like the Lenovo X270. The thin client should have an SD card reader for provisioning SD cards that the hosts will boot from if you are using CM4s. (Raspberry Pi 4Bs may be booted from a second USB key, however.) The thin client should also have one or two RJ-45 ports, depending on the number of networks in use. Finally, a dedicated USB key for installing / upgrading the thin client (which will host the boot volume for the device).</p>"},{"location":"hardware/#networking-hardware","title":"Networking Hardware","text":"<ul> <li>DeskPi Super6C when using Compute Module 4 Lites or Netgear unmanaged switches when using Raspberry Pi 4Bs</li> <li>Olimex USB Ethernet Adapter (https://www.olimex.com/Products/USB-Modules/USB-GIGABIT/open-source-hardware)</li> <li>One Ethernet cable per host.</li> </ul>"},{"location":"hardware/#host-hardware","title":"Host Hardware","text":"<p>TowerOS currently supports two kinds of host hardware: Raspberry Pi 4B and Compute Module 4 Lite (\u201cCM4\u201d for short). Whereas Raspberry Pi 4Bs must be connected with standalone switch hardware, CM4 modules may be connected with a board like the DeskPi Super6C, which provides for a much more compact form factor for a complete TowerOS system. CM4 modules may easily use M.2 SSDs as their persistent storage via a DeskPi Super6C, and they should therefore perform much better.</p>"},{"location":"hardware/#notes","title":"Notes","text":"<ul> <li>The amount of RAM required for each host is heavily dependent on the intended usage pattern. Generally, at least one host should have 8GB of RAM, to run a web browser. For the router host, we recommend having at least 2GB of RAM.</li> <li>Different SD cards and USB keys may have very different performance characteristics. In general, USB keys are much faster than SD cards, and M.2 SSDs are faster still.</li> <li>Each host needs two storage devices to function properly: one for the boot filesystem and another for the root filesystem (the one that contains your applications and data).<ul> <li>If your system is based on Raspberry PI 4Bs, you can use either an SD card or a USB key for each file system (It is recommended to use the fastest device for the root file system).</li> <li>For CM4s with a DeskPi, you must use an SD card for the boot file system and an M.2 SSD for the root file system.</li> <li>The decryption key for the root filesystem is stored directly on the boot device, so the user may remove this device when leaving the host hardware unattended to protect against data theft by physical means.</li> </ul> </li> </ul>"},{"location":"hardware/#compute-module-4-lite","title":"Compute Module 4 Lite","text":"<p>Using CM4s and the DeskPi Super6C Board you can avoid most cables and put all your hosts in a single mini-ITX case. This setup is more performant, more affordable and more compact. However, it is also more difficult to debug: the DeskPi only provides USB and HDMI access to slot #1 on the board, and hosts cannot be power cycled individually. To support both online and offline hosts, two independent DeskPi Super6s should be used; otherwise, a single DeskPi will support five online hosts plus the router.</p>"},{"location":"hardware/#requirements","title":"Requirements","text":"<ul> <li>Only the CM4 Lite is supported.</li> <li>Only the CM4 Lite module used for the router must have on-board WiFi (the others may be entirely wireless).</li> <li>N.B. With the DeskPi, it's possible to disable wireless connectivity for each CM4 with a jumper.</li> <li>CM4s must be booted from an SD card, which will hold the boot partition.</li> <li>Accordingly, you must have an SD Card reader for the thin client.</li> <li>CM4s must use an M.2 SSD for the root partition.</li> </ul>"},{"location":"hardware/#raspberry-pi-4b","title":"Raspberry Pi 4B","text":"<p>Using standard Raspberry Pi 4Bs for your system is most appropriate if it does not need to be portable, because of the additional bulk of the Raspberry Pi form factor. If you wish to support offline hosts, then you need two unmanaged switches; otherwise, one will do.</p>"},{"location":"hardware/#requirements_1","title":"Requirements","text":"<ul> <li>You will need either two USB keys, or one USB key and one SD card per host. (For best performance, the root partition should reside on a fast USB key, which should be plugged into the blue USB 3.0 port.)</li> <li>If you are using a PoE switch, you will need one PoE hat per host; if not, a USB hub may be used for power delivery.</li> <li>You will need one RTC Clock hat for each offline host.</li> </ul>"},{"location":"hardware/#hardware-for-debugging","title":"Hardware for Debugging","text":"<ul> <li>Monitor</li> <li>micro HDMI adapter</li> <li>USB Keyboard</li> <li>USB Mouse</li> </ul>"},{"location":"implementation/","title":"Implementation","text":"<p>TowerOS is built on Alpine Linux, because of Alpine's simplicity, minimalism, and security-first approach. TowerOS is open-source and freely licensed (under the Apache License 2.0). It is designed to require the smallest-possible trusted computing base, to rely only on other widely used open-source software, and to be as transparent as possible in its implementation.</p>"},{"location":"implementation/#tower-tools","title":"Tower Tools","text":"<p>The <code>toweros</code> package contains all of the tooling necessary to build TowerOS images for both the thin client and for the hosts (a pre-built image for the thin client\u2014containing a pre-built image for hosts---is available on the GitHub Releases page).</p> <p>This package is organized into six primary modules:</p> <ul> <li><code>buildthinclient.py</code> and <code>buildhost.py</code> to build the OS images used by the thin client and the hosts</li> <li><code>sshconf.py</code> which manages TowerOS and SSH configuration files</li> <li><code>provision.py</code>, <code>install.py</code>, and <code>gui.py</code> which allow you to provision a host, to install an application on it without an Internet connection, and to run a graphical application on a host from the thin client, respectively.</li> </ul>"},{"location":"implementation/#networking","title":"Networking","text":"<p>A TowerOS thin client connects to one or two separate networks of hosts (each network with an unmanaged switch). One network is connected to the Internet; the other (optional) network is offline. Online hosts reside on the first network; offline hosts on the second. On the online network, one of the hosts is the router: it is connected to the Internet directly and shares its connection with all the hosts connected to the same network.</p> <p>All IPs are static and assigned by the <code>tower</code> tool. Here are the IPs used:</p> <ul> <li>TOWER_NETWORK_ONLINE = \"192.168.2.0/24\"</li> <li>TOWER_NETWORK_OFFLINE = \"192.168.3.0/24\"</li> <li>THIN_CLIENT_IP_ETH0 = \"192.168.2.100\"</li> <li>THIN_CLIENT_IP_ETH1 = \"192.168.3.100\"</li> <li>ROUTER_IP = \"192.168.2.1\"</li> <li>FIRST_HOST_IP = 200 # 192.168.2.200 or 192.168.3.200</li> </ul>"},{"location":"implementation/#firewall-rules","title":"Firewall Rules","text":"<p>Firewalls are a primary element in the security of a TowerOS system. <code>iptables</code> is installed and configured on each host and on the thin client using the following two scripts:</p> <ul> <li>https://github.com/towercomputers/toweros/blob/dev/scripts/toweros-host/installer/configure-firewall.sh</li> <li>https://github.com/towercomputers/toweros/blob/dev/scripts/toweros-thinclient/installer/configure-firewall.sh</li> </ul> <p>Both of these scripts are destructive and idempotent: they clean all the rules at the beginning and save the new rules at the end.</p> <p>The thin client is configured with the following guide</p> <p>Hosts are configured the same way, but with the following additional rules:</p> <ul> <li>Port 22 is open to the thin client.</li> <li>Offline hosts reject all outgoing traffic.</li> <li>Online hosts reject outgoing traffic directed to the thin client or to other hosts.</li> <li>The router has IP forwarding active, to share its connection with the other online hosts.</li> </ul>"},{"location":"implementation/#building-your-own-toweros-images","title":"Building your own TowerOS Images","text":""},{"location":"implementation/#image-for-thin-clients","title":"Image for Thin Clients","text":"<p><code>buildthinclient.py</code> is the module responsible for generating an image of TowerOS with the <code>build-tower-image thinclient</code> command, which uses the <code>mkimage</code> tool (see https://wiki.alpinelinux.org/wiki/How_to_make_a_custom_ISO_image_with_mkimage).</p> <p>The installer contains all the APK and pip packages necessary for installing the base system and <code>toweros</code>, which is ready to use after the first boot. In this way, the installation of the system, as well as the provisioning of a first host, does not require an Internet connection.</p> <p>Here are the different steps taken by <code>buildthinclient.py</code> to generate an image:</p> <ol> <li> <p>Gathering the necessary builds. The script starts by checking for the existence of a <code>./dist</code>, <code>./builds</code> or <code>~/.cache/tower/builds/</code> folder. If one of them exists, this is where the script will fetch the builds and place the final image. If no folder exists, then the script creates the folder <code>~/.cache/tower/builds/</code>. Next:</p> <ol> <li>The script then verifies that the TowerOS host image is present. If not, it launches the build of a new image.</li> <li>The script checks for the existence of a <code>toweros</code> wheel package. If it does not exist the package is retrieved from GitHub.</li> </ol> </li> <li> <p>Downloading <code>pip packages with</code>pip download` in a cache folder</p> </li> <li> <p>Creating and updating an Alpine APK overlay folder, including most importantly:</p> <ol> <li>pip cache folder</li> <li>Add the system install BASH scripts (see https://github.com/towercomputers/toweros/tree/dev/scripts/toweros-thinclient)</li> <li>Include the TowerOS documentation</li> <li>Add the <code>/etc</code> configuration files</li> <li>Add builds required by <code>toweros</code> (TowerOS for the host, <code>toweros</code>)</li> </ol> </li> <li> <p>Launching <code>mkimage</code>, which takes care of the rest.</p> </li> <li> <p>Renaming and copying the image into the <code>builds</code> folder.</p> </li> <li> <p>Cleaning temporary files.</p> </li> </ol> <p>Notes about the TowerOS installer for the thin client:</p> <ul> <li>The install scripts generally follow the official Alpine Linux install guide.</li> <li>The installer sets up an <code>iptables</code> firewall as described in the Arch Linux Wiki.</li> <li>The script uses SysLinux as the boot loader.</li> </ul>"},{"location":"implementation/#image-for-hosts","title":"Image for Hosts","text":"<p><code>buildhost.py</code> is the module responsible for generating an image for the thin client when the <code>build-tower-image host</code> command is executed, and also for configuring the image when the <code>tower provision</code> command is called.</p> <p><code>buildhost.py</code> uses the same method as <code>pigen</code> to build an image for a Raspberry Pi (see https://github.com/RPi-Distro/pi-gen/blob/master/export-image/prerun.sh) but unlike <code>pigen</code>, which uses a Debian-based system, <code>buildhost.py</code> uses an Alpine Linux\u2013based system (see https://wiki.alpinelinux.org/wiki/Classic_install_or_sys_mode_on_Raspberry_Pi).</p> <p>The <code>tower provision</code> command finalises the configuration of the image, which is otherwise neither secure nor ready to be used by <code>toweros</code>.</p> <p>Here are the different steps taken by <code>buildhost.py</code> to generate an image:</p> <ol> <li> <p>Install an Alpine Linux system in a mounted temporary folder:</p> <ol> <li>Create an image file with <code>mkfs.ext4</code></li> <li>Mount this image with <code>mount</code></li> <li>Install a minimal Alpine Linux system, as well as NX, in the mounted folder (https://dl-cdn.alpinelinux.org/alpine/v3.17/releases/armv7/alpine-rpi-3.17.3-armv7.tar.gz)</li> </ol> </li> <li> <p>Create the necessary partitions with <code>parted</code> and stores them in an image file, with the sizes adapted for the system installed in step 1.</p> </li> <li> <p>Copy the installed system into the newly-created partitions with <code>rsync</code></p> </li> <li> <p>Compress the image containing the partitions</p> </li> <li> <p>Unmount and cleans up temporary files and folders</p> </li> </ol> <p>Here are the different steps taken by <code>buildhost.py</code> to configure an image when provisioning an host:</p> <ol> <li> <p>Copy the image to the SD card</p> </li> <li> <p>Grow the root partition to occupy entire SD card</p> </li> <li> <p>Place a <code>tower.env</code> file in the root directory of the boot partition. This file contains all the variables needed to install the system on the first boot (<code>HOSTNAME</code>, <code>USERNAME</code>, <code>PUBLIC_KEY</code>, ...).</p> </li> <li> <p>Unmount the SD card, which is ready to be inserted into the host device.</p> </li> </ol> <p>Note: A TowerOS image for the thin client is placed in the <code>~/.cache/tower/builds/</code> folder by the installer.</p>"},{"location":"implementation/#system-configuration","title":"System Configuration","text":"<p>All configuration files and keys used by <code>tower</code> are in the <code>~/.local/tower</code> folder. This folder contains:</p> <ul> <li> <p>the <code>config</code> file which contains the list of hosts. This file is compatible with <code>ssh</code> and is included in the <code>~/.ssh/config</code> file.</p> </li> <li> <p>one folder per host containing:</p> <ul> <li><code>tower.env</code> (configuration file used to install the host)</li> <li><code>id_ed25519</code> (ssh private key to connect to the host)</li> <li><code>id_ed25519.pub</code> (ssh public key)</li> <li><code>crypto_keyfile.bin</code> (luks key used to encrypt the host root disk)</li> <li><code>world</code> (installed apks with <code>tower install</code>)</li> </ul> </li> </ul>"},{"location":"implementation/#host-provisioning","title":"Host Provisioning","text":"<p><code>provision.py</code> is used by the <code>tower provision &lt;host&gt;</code> command to prepare an SD card directly usable by a Rasbperry Pi.</p> <p>The steps to provision a host are as follows:</p> <ol> <li>Gereate a key pair.</li> <li>Generate the host configuration (<code>tower.env</code>) with the values provided on the command line or with those retrieved from the thin client</li> <li>Copy of the TowerOS thin client image onto the SD card and include the configuration file</li> <li>Wait for the new host to be detected on the network after the user has inserted the SD card into the host device</li> <li>Update the <code>ssh</code> and <code>toweros</code> configuration files</li> </ol> <p>Once a host has been provisioned, it should be accessible with <code>$ ssh &lt;host&gt;</code> or <code>$ tower run &lt;host&gt; &lt;command&gt;</code>.</p>"},{"location":"implementation/#gui-application-execution","title":"GUI Application Execution","text":"<p><code>gui.py</code> is a module that allows the use of the NX protocol through an SSH tunnel: it allows the user run an application on one of the hosts from the safety of the thin client.</p> <p><code>nxagent</code> must be installed on the host, and <code>nxproxy</code> on the thin client. Of course, both are included in the TowerOS images.</p> <p>Here are the steps taken by <code>gui.py</code> to run an application on one of the hosts:</p> <ol> <li> <p>Generate a unique cookie which is added in the host with <code>xauth add</code></p> </li> <li> <p>Launch <code>nxagent</code> (configured to accept only local connections) on the host using <code>ssh</code></p> </li> <li> <p>Open an SSH tunnel between the host and the thin client on the port used by <code>nxagent</code></p> </li> <li> <p>Launch <code>nxproxy</code> with the generated cookie and on the port associated with the SSH tunnel</p> </li> </ol> <p>At this stage <code>nxproxy</code> and <code>nxagent</code> are connected, and we have a virtual screen, on which we run the graphical application with: <code>ssh &lt;host&gt; DISPLAY=:50 &lt;application-name&gt;application&gt;</code>.</p> <p>After the application has been closed, <code>gui.py</code> will perform the following actions:</p> <ol> <li>Terminate <code>nxagent</code> and close the SSH tunnel</li> <li>Revoke the cookie with <code>xauth remove</code></li> <li>Terminate <code>nxproxy</code></li> </ol> <p>The GUI system therefor works the same way as X2GO, which provided the inspiration.</p>"},{"location":"implementation/#package-management","title":"Package Management","text":"<p>This module allows to use of <code>apk</code> on an offline host through an SSH tunnel through the router. To do this, it performs the following steps:</p> <ol> <li> <p>Prepare the offline host to redirect requests to the APK repository to the thin client:</p> <ol> <li>Add <code>127.0.0.1 &lt;apk_repo_host&gt;</code> to the <code>/etc/hosts</code> file</li> <li>Add an <code>iptables</code> rule to redirect requests on port 80 to port 4443 (so you don't need to open the tunnel as <code>root</code>, port 80 being protected)</li> <li>Prepare a <code>pacman.conf</code> file containing only the <code>apk_repo_host</code></li> <li>Open a tunnel to redirect port 4443 on the offline host to port 4666 on the thin client.</li> </ol> </li> <li> <p>Open a tunnel to redirect port 4666 from thin client to the APK repository on the online host with: <code>ssh -R 4666:&lt;apk_repo_host&gt;:80 &lt;online-host&gt;</code></p> </li> </ol> <p>At this point the module can normally use <code>apk</code> with <code>ssh</code> on the offline host to install the desired packages</p> <p>Once the installation has finished, <code>gui.py</code> cleans the <code>/etc/hosts</code> file and the <code>iptables</code> rules from the offline host and closes the SSH tunnels.</p> <p>Note: when installing each package, <code>apk</code> verifies that it has been signed by the authors and maintainers of Alpine Linux. Therefore it is not necessary to trust the online host, but rather to initialise the APK keys in a trusted environment. For users of TowerOS, this means it is imperative to build the TowerOS images in a trusted environment and to manually verify the integrity of the keys.</p>"},{"location":"installation/","title":"TowerOS Installation","text":""},{"location":"installation/#thin-client-installation","title":"Thin Client Installation","text":"<p>To use TowerOS, you must first install the image for the thin client on the device you wish to use (normally a laptop):</p> <ol> <li>Download the latest image here: https://github.com/towercomputers/toweros/releases/latest.</li> <li>Prepare a bootable USB medium using the above image.</li> <li>Boot the thin client with the USB drive and follow the instructions.</li> </ol>"},{"location":"installation/#provisioning-hosts","title":"Provisioning Hosts","text":"<p>Hosts are divided into two types: online and offline. Online hosts live on a separate LAN from offline hosts, and the thin client is connected to both networks. One online host is deemed the \u201crouter\u201d, and the router is responsible for providing Internet access to the thin client and all other hosts. If you do not wish to maintain two separate networks, you can simply not provision any offline hosts.</p> <p>TowerOS provides tools for easily provisioning new hosts with the following steps, with the user guided through them by the <code>tower</code> CLI tool:</p> <ol> <li>Insert the root device (SD card or USB key for RPI, M.2 SSD for CM4) into the host hardware.</li> <li>Insert the boot device (SD card or USB key for RPI, SD card for CM4) into the thin client.</li> <li>Call the <code>[thinclient]$ tower provision</code> command to prepare the boot device.</li> <li>Remove the boot device from the thin client and insert it into the target host hardware.</li> <li>Turn on the host hardware.</li> <li>Wait for the provisioning process to complete on the thin client.</li> </ol> <p>NOTE: You must provision a router before you provision any other online hosts.</p> <p>NOTE: It is a good idea to reserve one (offline) host for managing removable storage (esp. when using the DeskPi Super6C and CM4s, since then only one host has USB ports exposed).</p>"},{"location":"installation/#provision-the-router","title":"Provision the Router","text":"<p>The first online host that you must provision is the router, which connect to the Internet via a WiFi network: </p> <pre><code>[thinclient]$ tower provision router \u2013wlan-ssid &lt;ssid&gt; \u2013wlan-password &lt;password&gt;\n</code></pre>"},{"location":"installation/#provision-an-online-host","title":"Provision an Online Host","text":"<p>Once the <code>router</code> is correctly provisioned, you may provision other online hosts:</p> <pre><code>[thinclient]$ tower provision &lt;host&gt; --online\n</code></pre>"},{"location":"installation/#provision-an-offline-host","title":"Provision an Offline Host","text":"<p>An offline host is a host without access to the Internet via the router.</p> <pre><code>[thinclient]$ tower provision &lt;host&gt; --offline\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>In case a host is not accessible:</p> <ul> <li>either by the provisioning script</li> <li>either with <code>ssh &lt;host&gt;</code></li> <li>either appears as \"down\" with <code>tower status</code></li> </ul> <p>The most likely cause is a network problem. Here is the list of checks to carry out:</p> <ol> <li>With <code>ip ad</code> check that the interface <code>eth0</code> is UP and with the ip <code>192.168.2.100</code> and that the interface <code>eth1</code> is UP with the ip <code>192.168.3.100</code>.</li> <li>check that the Thin Client is connected to the online switch with <code>eth0</code> and to the offline switch with <code>eth1</code>.</li> <li>check that the host is connected to the correct switch</li> <li>check that the host is visible with <code>nmap -sn 192.168.2.0/24</code> for an online host and <code>nmap -sn 192.168.3.0/24</code> for an offline host.</li> </ol> <p>If all of these checks are ok and you still cannot access the host, you must connect a screen and keyboard to the host and check for any error messages.</p>"},{"location":"installation/#thin-client-upgrades","title":"Thin Client Upgrades","text":"<p>To upgrade the thin client you must proceed in exactly the same way as for the installation and select \"Upgrade TowerOS-Thinclient\" in the first question.</p> <p>During an upgrade the system is completely reinstalled. Only the <code>/home</code> folder with hosts configurations and keys are kept. If you have data outside of <code>/home</code>, make sure to make a backup before starting the upgrade.</p>"},{"location":"installation/#host-upgrades","title":"Host Upgrades","text":"<pre><code>[thinclient]$ tower upgrade &lt;host&gt;\n</code></pre> <p>During an upgrade the system is completely reinstalled. Only the /home folder is kept. If you have data outside of /home, make sure to make a backup before starting the upgrade.</p> <p>Once the system is upgrade, all applications installed with <code>tower install &lt;host&gt;</code> are automatically re-installed.</p> <p>Note: Always upgrade the router before other hosts.</p>"},{"location":"secure-boot/","title":"Secure Boot","text":"<p>Secure Boot is a security feature that is implemented in the BIOS and does not require special hardware. Secure Boot ensures that each component launched during the boot process is digitally signed, and that the signature is validated against a set of trusted certificates embedded in the UEFI BIOS.</p> <p>TowerOS offers the possibility to activate Secure Boot on the thin client. To do this, the firmware must be correctly configured before and after installation.</p>"},{"location":"secure-boot/#before-the-installation","title":"Before the installation","text":"<p>You must:</p> <ul> <li>Disable Secure Boot if necessary</li> <li>Reset to \"Setup Mode\"</li> <li>Clear all secure boot keys that have already been registered</li> </ul> <p>On ThinkPad firmware, these three things can be done on the same screen:</p> <p></p>"},{"location":"secure-boot/#after-the-installation","title":"After the installation","text":"<p>You must enable the \"Secure Boot\" feature on the same screen.</p> <p>Attention---once activated, you will not be able to boot from unsigned devices, for example a live system on an USB key. It will first be necessary to deactivate the Secure Boot feature.</p> <p>Remember to make a backup of the private keys used for Secure Boot, which are located here by default in <code>/usr/share/secureboot/keys/</code>.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#security-model","title":"Security Model","text":"<ul> <li>Direct communication between hosts is forbidden.</li> <li>Incoming connections to the thin client are forbidden.</li> <li>All communication with a host must originate with the thin client and be:<ul> <li>over SSH,</li> <li>on port 22, and</li> <li>via Ethernet.</li> </ul> </li> <li>All communication between the thin client and a host must be directly triggered by user action.</li> <li>SSH tunnels from the thin client or an online host to the Internet, through the router, are allowed.</li> <li>Risks of data compromise by device theft are mitigated using encryption of the root filesystem of every host. However, for usability reasons, it's not practical to require passphrase input on each boot\u2014the decryption key is stored on a separate boot device, and the user may remove this device when leaving the host hardware unattended.</li> </ul>"},{"location":"security/#operating-system","title":"Operating System","text":"<p>In general, operating system configuration is outside the scope of TowerOS's responsibilities; TowerOS does attempt to be secure by default, however. Of course, the core architecture of TowerOS is designed to mitigate the severity of any compromise of a host. For information on how best to securing your thin client and hosts at the level of the operating system, please see this Linux Hardening Guide.</p>"},{"location":"security/#thin-client-security","title":"Thin-Client Security","text":"<p>The thin client is the root of trust of the system. To avoid accidentally compromising the thin client, avoid installing unnecessary software and never open any untrusted files, except on a host.</p>"},{"location":"security/#router-security","title":"Router Security","text":"<p>Best practice is never to install any software on the router host, nor open any untrusted files on it either.</p>"},{"location":"security/#full-disk-encryption","title":"Full-Disk Encryption","text":"<p>TowerOS requires that the root device used by the thin client and hosts be encrypted. The decryption keys for these drives are stored on the boot device, which is itself a removable drive: the thin client's boot device should be a USB key; the host's may be either an SD card or a USB key (when using Compute Modules, they must be SD cards). It is therefore best practice to remove these drives from the relevant devices as soon as they have been booted up, and especially before they are left unattended.</p> <p>Note: The reason that the decryption keys are stored on removable drives---rather than themselves being stored locally  and decrypted with passphrases---is the impracticaly of requiring the user to give direct keyboard input to all of the devices on booting the system. In case you would like to store these device decryption keys more securely, it is recommended that you use for a boot device a USB key with hardware-based encryption that can be accessed with a PIN, for instance a Kingston Ironkey Locker+ 50 or an Apricorn Aegis Secure Key 3 NX.</p>"},{"location":"security/#trusted-computing-base","title":"Trusted Computing Base","text":"<ul> <li>TowerOS Tooling</li> <li>Alpine Linux Base System</li> <li>Network Drivers</li> <li>Network Card Hardware</li> <li>SSH</li> <li>NX (Screensharing)</li> </ul>"},{"location":"security/#threat-analysis","title":"Threat Analysis","text":"Class Attack Mitigated If so, how? Theft Theft of Device Yes Encrypted root disks Physical Tampering Evil-Maid Attack Optional Raspberry Pis: Zymbit Physical Tampering Cold-Boot Attack Optional Raspberry Pis: Zymbit Microarchitectural RowHammer; RowPress Yes Host-Isolation Microarchitectural Speculative Execution Yes Host-Isolation Physical Side-Channel Power Consumption (e.g. Hertzbleed) Optional Disable DVFS Physical Side-Channel Acoustic Emissions No Physical Side-Channel Electromagnetic Radiation No"},{"location":"security/#tor-proxy","title":"Tor Proxy","text":"<p>Tor is installed by default on the router and a SOCKS5 proxy is available on port 9050 for all online hosts. You can use this proxy by properly configuring your favorite application.</p> <p>For example if you have an online host called <code>web</code>:</p> <pre><code>[thinclient]$ ssh web curl --socks5 192.168.2.1:9050 https://check.torproject.org/api/ip\n</code></pre>"},{"location":"security/#common-attack-vectors","title":"Common Attack Vectors","text":""},{"location":"usage/","title":"Using TowerOS","text":"<p>Once your hosts have been provisioned, you are ready to use TowerOS. You can of course access each host via SSH. However, you can also run GUI applications installed on a host such that the application appears to run on the thin client.</p>"},{"location":"usage/#execute-a-command-on-one-of-the-hosts","title":"Execute a command on one of the hosts","text":"<p>Run a command on a host with SSH:</p> <pre><code>[thinclient]$ ssh &lt;host&gt; &lt;command&gt;\n</code></pre>"},{"location":"usage/#run-a-graphical-application-on-a-host-with-its-gui-appearing-on-the-thin-client","title":"Run a graphical application on a host, with its GUI appearing on the thin client","text":"<pre><code>[thinclient]$ tower run &lt;host&gt; &lt;command&gt;\n</code></pre>"},{"location":"usage/#install-an-alpine-package-on-a-host","title":"Install an Alpine package on a host","text":"<p>TowerOS makes it easy to install new packages on any host by tunneling a connection through the router:</p> <pre><code>[thinclient]$ tower install &lt;host&gt; &lt;package&gt;\n</code></pre>"},{"location":"usage/#list-your-hosts-and-their-statuses","title":"List your hosts and their statuses","text":"<pre><code>[thinclient]$ tower status\n</code></pre>"},{"location":"usage/#get-thin-client-and-host-versions","title":"Get thin client and host versions","text":"<pre><code>[thinclient]$ tower version\n</code></pre>"},{"location":"usage/#update-router-wifi-credentials","title":"Update <code>router</code> wifi credentials","text":"<pre><code>[thinclient]$ tower wlan-connect --ssid &lt;ssid&gt; --password &lt;password&gt;\n</code></pre>"}]}