{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"development/","title":"Development","text":""},{"location":"development/#set-up-development-environment","title":"Set Up Development Environment","text":"<p>To connect the thin client to the Internet you must:</p> <ol> <li>Provision a <code>router</code>.</li> <li>Set the gateway on the thin client to <code>192.168.2.1</code> (the router's IP address):</li> </ol> <p>The file <code>/etc/network/interfaces</code> must contain the following:</p> <pre><code>auto lo\niface lo inet loopback\nauto eth0\niface eth0 inet static\n    address 192.168.2.100/24\n    gateway 192.168.2.1\nauto eth1\niface eth1 inet static\n    address 192.168.3.100/24\nEOF\n</code></pre> <ol> <li>Set the DNS server on the thin client:</li> </ol> <p>The file <code>/etc/resolv.conf</code> must contain the following:</p> <pre><code>nameserver 8.8.8.8\nnameserver 8.8.4.4\n</code></pre> <ol> <li>Restart the network with: <code>[thinclient]$ sudo rc-service networking restart</code>:</li> </ol> <p>Configure <code>git</code>, download Github repository in <code>~/towercomputers/toweros</code> and install <code>hatch</code> with:</p> <pre><code>[thinclient]$ ~/install-dev.sh &lt;git-name&gt; &lt;git-email&gt; &lt;git-private-key-path&gt;\n</code></pre>"},{"location":"development/#use-toweros-with-hatch","title":"Use TowerOS with <code>hatch</code>:","text":"<pre><code>[thinclient]$ git clone git@github.com:towercomputers/toweros.git\n[thinclient]$ cd toweros\n[thinclient]$ pip install hatch\n[thinclient]$ hatch run tower --help\n[thinclient]$ hatch run build-tower-image --help\n</code></pre>"},{"location":"development/#manually-qa-toweros-for-thin-client","title":"Manually QA TowerOS for Thin Client","text":"<p>On first boot:</p> <ol> <li> <p>Basic checking</p> </li> <li> <p>The \u201cwelcome message\u201d should refer to TowerOS.</p> </li> <li>The README, whitepaper and <code>install-dev.sh</code> script should be found in <code>~/</code>.</li> <li>The <code>wheel</code> package and host image should be in <code>~/.cache/tower/builds</code>.</li> <li><code>$ iptables -L -v</code> should show firewall rules, and <code>/var/logs/iptables.log</code> should contain firewall logs.</li> <li> <p><code>lo</code> and <code>eth0</code> should be up (check  with <code>$ ip ad</code>)</p> </li> <li> <p>Provision an online host:</p> </li> </ol> <pre><code>[thinclient]$ tower provision web --online --wlan-ssid &lt;ssid&gt; --wlan-password &lt;password&gt; --sd-card /dev/sdb \n</code></pre> <ol> <li>Provision an offline host:</li> </ol> <pre><code>[thinclient]$ tower provision office --offline --sd-card /dev/sdb\n</code></pre> <ol> <li>Check system status:</li> </ol> <pre><code>[thinclient]$ tower status\n</code></pre> <ol> <li>Install a package an an offline host:</li> </ol> <pre><code>[thinclient]$ tower install office xcalc --online-host office\n</code></pre> <ol> <li>Install a package on an online host:</li> </ol> <pre><code>[thinclient]$ tower install web midori\n</code></pre> <ol> <li>Test installed packages:</li> </ol> <pre><code>[thinclient]$ startx\n[thinclient]$ tower run office xcalc\n[thinclient]$ tower run web midori\n</code></pre> <p>Check also if the Xfce Application menu contains shortcuts for installed packages.</p> <ol> <li> <p>Log out from Xfce and connect to the Internet as described above.</p> </li> <li> <p>Build a host TowerOS image with:</p> </li> </ol> <pre><code>[thinclient]$ buld-tower-image host\n</code></pre> <ol> <li>Build a thin client TowerOS image with:</li> </ol> <pre><code>[thinclient]$ buld-tower-image thinclient\n</code></pre> <ol> <li>Install the development environment with:</li> </ol> <pre><code>[thinclient]$ ~/install-dev.sh &lt;git-name&gt; &lt;git-email&gt; &lt;git-private-key-path&gt;\n</code></pre> <ol> <li>If you are feeling brave, you may repeat all these steps with the thin client image you generated yourself. :)</li> </ol>"},{"location":"development/#build-your-own-custom-thin-client-linux","title":"Build your own custom Thin Client (Linux)","text":""},{"location":"development/#install-dependencies","title":"Install Dependencies","text":"<pre><code>[thinclient]$ apk add alpine-base coreutils python3 py3-pip py3-rich sudo openssh dhcpcd avahi \\\n      avahi-tools wpa_supplicant rsync git iptables rsync lsblk perl-utils xz \\\n      musl-locales e2fsprogs-extra nx-libs xsetroot mcookie parted lsscsi figlet \\\n      alpine-sdk build-base apk-tools acct acct-openrc alpine-conf sfdisk busybox \\\n      fakeroot syslinux xorriso squashfs-tools mtools dosfstools grub-efi abuild \\\n      agetty runuser nano vim net-tools losetup xorg-server xf86-input-libinput \\\n      xinit udev xfce4 xfce4-terminal xfce4-screensaver adw-gtk3 \\\n      adwaita-xfce-icon-theme setxkbmap\n</code></pre>"},{"location":"development/#enable-basic-services","title":"Enable Basic Services","text":"<p>If necessary, enable IPv4 with:</p> <pre><code>[thinclient]$ sed -i 's/noipv4ll/#noipv4ll/' /etc/dhcpcd.conf\n</code></pre> <p>then</p> <pre><code>[thinclient]$ rc-update add dhcpcd\n[thinclient]$ rc-update add avahi-daemon\n[thinclient]$ rc-update add iptables\n[thinclient]$ rc-update add networking\n[thinclient]$ rc-update add wpa_supplicant boot\n[thinclient]$ rc-update add dbus\n</code></pre> <p>Important: Make sure you are connected to the switch and check that your first wired interface (starting with the letter <code>e</code>) has an assigned IP.</p>"},{"location":"development/#update-etcsudoers-and-groups","title":"Update <code>/etc/sudoers</code> and groups:","text":"<p>The <code>toweros</code> software assumes that the current user has full <code>sudo</code> access with no password. (Please refer to our threat model.) Check if <code>/etc/sudoers</code> contains the following line:</p> <pre><code>&lt;your_username&gt; ALL=(ALL) NOPASSWD: ALL\n</code></pre> <p>To build an image with <code>build-tower-image</code>, you first need to add the current user in the <code>abuild</code> group:</p> <pre><code>[thinclient]$ addgroup &lt;you_username&gt; abuild\n</code></pre>"},{"location":"development/#install-the-toweros-tools","title":"Install the <code>toweros</code> tools:","text":"<p>Update <code>pip</code> to the latest version:</p> <pre><code>[thinclient]$ python3 -m pip install --upgrade pip\n</code></pre> <p>Install the <code>toweros</code> toolkit with <code>pip</code>:</p> <pre><code>[thinclient]$ python3 -m pip install \"toweros @ git+ssh://github.com/towercomputers/toweros.git\"\n</code></pre>"},{"location":"development/#build-a-host-image","title":"Build a host image:","text":"<pre><code>[thinclient]$ build-tower-image host\n</code></pre> <p>This will generate an image file compressed with xz in <code>~/.cache/tower/builds/</code>. Images in this folder will be used by default by the provision command (if the <code>--image</code> flag is not provided).</p>"},{"location":"development/#build-a-toweros-image-with-docker","title":"Build a TowerOS image with Docker","text":"<p>Build the Docker image with:</p> <pre><code>[thinclient]$ git clone git@github.com:towercomputers/toweros.git\n[thinclient]$ cd tools\n[thinclient]$ hatch build -t wheel\n[thinclient]$ docker build -t build-tower-image:latest .\n</code></pre> <p>Then build the TowerOS image inside a Docker container:</p> <pre><code>[thinclient]$ docker run --name towerbuilder --user tower --privileged -v /dev:/dev build-tower-image thinclient\n</code></pre> <p>Retrieve that image from the container:</p> <pre><code>[thinclient]$ docker cp towerbuilder:/home/tower/.cache/tower/builds/toweros-thinclient-0.0.1-20230513171731-x86_64.iso ./\n</code></pre> <p>Finally delete the container with:</p> <pre><code>[thinclient]$ docker rm towerbuilder\n</code></pre> <p>Note: With the ARM64 architecture, you must use <code>buildx</code> and a cross-platform emulator like <code>tonistiigi/binfmt</code>.</p> <pre><code>[thinclient]$ docker buildx create --use\n[thinclient]$ docker buildx build -t build-tower-image:latest --platform=linux/amd64 --output type=docker .\n[thinclient]$ docker run --privileged --rm tonistiigi/binfmt --install all\n[thinclient]$ docker run --platform=linux/amd64 --name towerbuilder --user tower --privileged -v /dev:/dev \\\n              build-tower-image thinclient\n</code></pre>"},{"location":"hardware/","title":"Hardware","text":"<p>TowerOS is designed to run on a thin client device and several hosts connected via one or two unmanaged Ethernet switches. Two switches are necessary if the user would like to have offline as well as online hosts.</p> <p>The thin client is typically a laptop like the Lenovo X270. The thin client should have an SD card reader for provisioning SD cards that the hosts will boot from. (Raspberry Pi 4Bs may be booted directly from USB, however.) The thin client should also have one or two RJ-45 ports, depending on the number of switches in use.</p>"},{"location":"hardware/#thin-client-hardware-recommendations","title":"Thin Client Hardware Recommendations","text":"<ul> <li>Lenovo X270 Laptop</li> <li>Olimex USB Ethernet Adapter (https://www.olimex.com/Products/USB-Modules/USB-GIGABIT/open-source-hardware)</li> <li>USB SD Card reader</li> <li>2 Ethernet Cables</li> </ul>"},{"location":"hardware/#host-hardware-recommendations","title":"Host Hardware Recommendations","text":"<p>TowerOS currently supports two kinds of host hardware: Raspberry Pi 4B and Compute Module 4 Lite (\u201cCM4\u201d for short). Where as Raspberry Pi 4Bs must be connected with standalone switch hardware, CM4 modules may be connected with a board like the DeskPi Super6C, which provides for a much more compact form factor for a complete TowerOS system. CM4 modules may easily use M.2 SSDs as their persistent storage, via a DeskPi Super6C, and they may therefore perform better.</p> <p>Notes - The amount of RAM required for each host is heavily dependent on the intended usage pattern. Generally, at least one host should have 8GB of RAM, to run a web browser. For the router host, we recommend having at least 2GB of RAM. - Different SD cards and USB keys may have very different performance characteristics. In general, USB keys are much faster than SD cards, and M.2 SSDs are faster still.</p>"},{"location":"hardware/#raspberry-pi-4b","title":"Raspberry Pi 4B","text":"<ul> <li>Raspberry Pis may be booted either from an SD card or a USB key. For best performance, the root partition should reside on a USB key. You will need at least one SD card or USB key per host.</li> <li>The USB key should ideally be plugged into the blue USB port, which supports USB 3.0.</li> <li>If you wish to have offline hosts, then you need two switches; otherwise, one will do.</li> <li>If you are using a PoE switch, you will need one PoE hat per host; if not, a USB hub may be used for power delivery</li> <li>You will need one RJ-45 cable per host.</li> <li>You will need one RTC Clock hat for each offline host.</li> </ul>"},{"location":"hardware/#compute-module-4-lite","title":"Compute Module 4 Lite","text":"<p>Using CM4s and the DeskPi Super6C Board you can avoid most cables and put all your hosts in a single mini-ITX case.</p> <ul> <li>Only the CM4 Lite is supported.</li> <li>Only the CM4 Lite module used for the router must have on-board WiFi; the others may be entirely wireless.</li> <li>CM4s must be booted from an SD card, which will hold the boot partition.</li> <li>CM4s must use an M.2 SSD for the root partition (which also should be highly performant).</li> <li>To support both online and offline hosts, two independent DeskPi Super6s may be used.</li> </ul>"},{"location":"hardware/#hardware-for-debugging","title":"Hardware for Debugging","text":"<ul> <li>Monitor</li> <li>micro HDMI adapter</li> <li>USB Keyboard</li> <li>USB Mouse</li> </ul>"},{"location":"implementation/","title":"Implementation","text":"<p>The <code>tower-tools</code> package contains six main modules:</p> <ul> <li><code>buildthinclient.py</code> and <code>buildhost.py</code> to build the OS images used by the thin client and the hosts</li> <li><code>sshconf.py</code> which manages <code>tower-tools</code> and SSH configuration files</li> <li><code>provision.py</code>, <code>install.py</code>, and <code>gui.py</code> which respectively allow you to provision a host, to install an application on it without an Internet connection, and to run a graphical application on a host from the thin client</li> </ul>"},{"location":"implementation/#network-architecture","title":"Network Architecture","text":"<p>A TowerOS thin client is connected to one or two separate networks (each with an unmanaged switch). One network is connected to the Internet; the other (optional) network is offline. Online hosts reside on the first network; offline hosts on the second. On the online network, one of the hosts, called the \u201crouter\u201d, is connected to the Internet and shares the connection with all the hosts connected to the same network.</p> <p>All IPs are static and assigned by the <code>tower</code> tool. Here are the IPs used:</p> <ul> <li>TOWER_NETWORK_ONLINE = \"192.168.2.0/24\"</li> <li>TOWER_NETWORK_OFFLINE = \"192.168.3.0/24\"</li> <li>THIN_CLIENT_IP_ETH0 = \"192.168.2.100\"</li> <li>THIN_CLIENT_IP_ETH1 = \"192.168.3.100\"</li> <li>ROUTER_IP = \"192.168.2.1\"</li> <li>FIRST_HOST_IP = 200 # 192.168.2.200 or 192.168.3.200</li> </ul>"},{"location":"implementation/#firewall-rules","title":"Firewall Rules","text":"<p>Firewalls are critical elements for securing a TowerOS system. <code>iptables</code> is installed and configured on each host and on the thinclient using the following two scripts:</p> <ul> <li>https://github.com/towercomputers/tools/blob/dev/scripts/toweros-host/installer/configure-firewall.sh</li> <li>https://github.com/towercomputers/tools/blob/dev/scripts/toweros-thinclient/installer/configure-firewall.sh</li> </ul> <p>Both of these scripts are destructive and idempotent: they clean all the rules at the beginning and save the new rules at the end.</p> <p>The thin client is configured with the following guide</p> <p>Hosts are configured the same way, but with the following additional rules:</p> <ul> <li>Port 22 is open to the thin client.</li> <li>Offline hosts reject all outgoing traffic.</li> <li>Online hosts reject outgoing traffic directed to the thin client or to other hosts.</li> <li>The router has IP forwarding active, to share its connection with the other online hosts.</li> </ul>"},{"location":"implementation/#toweros-for-the-thin-client","title":"TowerOS for the Thin Client","text":"<p><code>buildthinclient.py</code> is the module responsible for generating an image of TowerOS with the <code>build-tower-image thinclient</code> command.</p> <p>TowerOS is based on Alpine Linux, and <code>buildthinclient.py</code> uses the <code>mkimage</code> tool (see https://wiki.alpinelinux.org/wiki/How_to_make_a_custom_ISO_image_with_mkimage).</p> <p>The installer contains all the APK and pip packages necessary for installing the base system and <code>tower-tools</code>, which is ready to use after the first boot. In this way, the installation of the system, as well as the provisioning of a first host, does not require an Internet connection.</p> <p>Here are the different steps taken by <code>buildthinclient.py</code> to generate an image:</p> <ol> <li> <p>Gathering the necessary builds. The script starts by checking for the existence of a <code>./dist</code>, <code>./builds</code> or <code>~/.cache/tower/builds/</code> folder. If one of them exists, this is where the script will fetch the builds and place the final image. If no folder exists, then the script creates the folder <code>~/.cache/tower/builds/</code>. Next:</p> <ol> <li>The script then verifies that the TowerOS host image is present. If not, it launches the build of a new image.</li> <li>The script checks for the existence of a <code>tower-tools</code> wheel package. If it does not exist the package is retrieved from GitHub.</li> </ol> </li> <li> <p>Downloading <code>pip packages with</code>pip download` in a cache folder</p> </li> <li> <p>Creating and updating an Alpine APK overlay folder, including most importantly:</p> <ol> <li>pip cache folder</li> <li>Add the system install BASH scripts (see https://github.com/towercomputers/tower-tools/tree/dev/scripts/toweros-thinclient)</li> <li>Include the TowerOS documentation</li> <li>Add the <code>/etc</code> configuration files</li> <li>Add builds required by <code>tower-tools</code> (TowerOS for the host, <code>tower-tools</code>)</li> </ol> </li> <li> <p>Launching <code>mkimage</code>, which takes care of the rest.</p> </li> <li> <p>Renaming and copying the image into the <code>builds</code> folder.</p> </li> <li> <p>Cleaning temporary files.</p> </li> </ol> <p>Notes about the TowerOS installer for the thin client:</p> <ul> <li>The install scripts generally follow the official Alpine Linux install guide.</li> <li>The installer sets up an <code>iptables</code> firewall as described in the Arch Linux Wiki.</li> <li>The script uses SysLinux as the boot loader.</li> </ul>"},{"location":"implementation/#toweros-for-hosts","title":"TowerOS for Hosts","text":"<p><code>buildhost.py</code> is the module responsible for generating an image for the thin client when the <code>build-tower-image host</code> command is executed, and also for configuring the image when the <code>tower provision</code> command is called.</p> <p><code>buildhost.py</code> uses the same method as <code>pigen</code> to build an image for a Raspberry Pi (see https://github.com/RPi-Distro/pi-gen/blob/master/export-image/prerun.sh) but unlike <code>pigen</code>, which uses a Debian-based system, <code>buildhost.py</code> uses an Alpine Linux\u2013based system (see https://wiki.alpinelinux.org/wiki/Classic_install_or_sys_mode_on_Raspberry_Pi).</p> <p>The <code>tower provision</code> command finalises the configuration of the image, which is otherwise neither secure nor ready to be used by <code>tower-tools</code>.</p> <p>Here are the different steps taken by <code>buildhost.py</code> to generate an image:</p> <ol> <li> <p>Install an Alpine Linux system in a mounted temporary folder:</p> <ol> <li>Create an image file with <code>mkfs.ext4</code></li> <li>Mount this image with <code>mount</code></li> <li>Install a minimal Alpine Linux system, as well as NX, in the mounted folder (https://dl-cdn.alpinelinux.org/alpine/v3.17/releases/armv7/alpine-rpi-3.17.3-armv7.tar.gz)</li> </ol> </li> <li> <p>Create the necessary partitions with <code>parted</code> and stores them in an image file, with the sizes adapted for the system installed in step 1.</p> </li> <li> <p>Copy the installed system into the newly-created partitions with <code>rsync</code></p> </li> <li> <p>Compress the image containing the partitions</p> </li> <li> <p>Unmount and cleans up temporary files and folders</p> </li> </ol> <p>Here are the different steps taken by <code>buildhost.py</code> to configure an image when provisioning an host:</p> <ol> <li> <p>Copy the image to the SD card</p> </li> <li> <p>Grow the root partition to occupy entire SD card</p> </li> <li> <p>Place a <code>tower.env</code> file in the root directory of the boot partition. This file contains all the variables needed to install the system on the first boot (<code>HOSTNAME</code>, <code>USERNAME</code>, <code>PUBLIC_KEY</code>, ...).</p> </li> <li> <p>Unmount the SD card, which is ready to be inserted into the host device.</p> </li> </ol> <p>Note: A TowerOS image for the thin client is placed in the <code>~/.cache/tower/builds/</code> folder by the installer.</p>"},{"location":"implementation/#sshconf","title":"SSHConf","text":"<p><code>tower-tools</code> uses a single configuration file in the same format as an SSH config file: <code>~/.ssh/tower.conf</code>. This file, referenced in <code>~/.ssh/config</code>, is used both by <code>tower-tools</code> to maintain the list of hosts and by <code>ssh</code> to access hosts directly with <code>ssh &lt;host&gt;</code>. The script <code>sshconf.py</code> is responsible for maintaining this file and generally anything that requires manipulation of something in the <code>~./ssh</code> folder. Notably:</p> <ol> <li>discovering the IP of a newly installed host and updating <code>tower.conf</code> accordingly</li> <li>updating <code>~/.ssh/know_hosts</code></li> <li>checking the status of a host and if it is online</li> </ol> <p>Note: <code>sshconf.py</code> uses https://pypi.org/project/sshconf/ to manipulate <code>ssh</code> config files.</p>"},{"location":"implementation/#provision","title":"Provision","text":"<p><code>provision.py</code> is used by the <code>tower provision &lt;host&gt;</code> command to prepare an SD card directly usable by a Rasbperry Pi.</p> <p>The steps to provision a host are as follows:</p> <ol> <li>Gereate a key pair.</li> <li>Generate the host configuration (<code>tower.env</code>) with the values provided on the command line or with those retrieved from the thin client</li> <li>Copy of the TowerOS thin client image onto the SD card and incclude the configuration file</li> <li>Wait for the new host to be detected on the network after the user has inserted the SD card into the host device</li> <li>Update the <code>ssh</code> and <code>tower-tools</code> configuration files</li> </ol> <p>Once a host has been provisioned, it should be accessible with <code>$ ssh &lt;host&gt;</code> or <code>$ tower run &lt;host&gt; &lt;command&gt;</code>.</p>"},{"location":"implementation/#gui","title":"GUI","text":"<p><code>gui.py</code> is a module that allows the use of the NX protocol through an SSH tunnel: it allows the user run an application on one of the hosts from the safety of the thin client.</p> <p><code>nxagent</code> must be installed on the host, and <code>nxproxy</code> on the thin client. Of course, both are included in the TowerOS images.</p> <p>Here are the steps taken by <code>gui.py</code> to run an application on one of the hosts:</p> <ol> <li> <p>Generate a unique cookie which is added in the host with <code>xauth add</code></p> </li> <li> <p>Launch <code>nxagent</code> (configured to accept only local connections) on the host using <code>ssh</code></p> </li> <li> <p>Open an SSH tunnel between the host and the thin client on the port used by <code>nxagent</code></p> </li> <li> <p>Launch <code>nxproxy</code> with the generated cookie and on the port associated with the SSH tunnel</p> </li> </ol> <p>_At this stage <code>nxproxy</code> and <code>nxagent</code> are connected, and we have a virtual screen, on which we run the graphical application with: <code>ssh &lt;host&gt; DISPLAY=:50 &lt;application-name&gt;application&gt;</code>.</p> <p>After the application has been closed, <code>gui.py</code> will perform the following actions:</p> <pre><code>1. Terminate `nxagent` and close the SSH tunnel\n2. Revoke the cookie with `xauth remove`\n3. Terminate `nxproxy`\n</code></pre> <p>The GUI system therefor works the same way as X2GO, which provided the inspiration.</p>"},{"location":"implementation/#install","title":"Install","text":"<p>This module allows to use of <code>apk</code> on an offline host through an SSH tunnel through the router. To do this, it performs the following steps:</p> <ol> <li> <p>Prepare the offline host to redirect requests to the APK repository to the thin client:</p> <ol> <li>Add <code>127.0.0.1 &lt;apk_repo_host&gt;</code> to the <code>/etc/hosts</code> file</li> <li>Add an <code>iptables</code> rule to redirect requests on port 80 to port 4443 (so you don't need to open the tunnel as <code>root</code>, port 80 being protected)</li> <li>Prepare a <code>pacman.conf</code> file containing only the <code>apk_repo_host</code></li> <li>Open a tunnel to redirect port 4443 on the offline host to port 4666 on the thin client.</li> </ol> </li> <li> <p>Open a tunnel to redirect port 4666 from thin client to the APK repository on the online host with: <code>ssh -R 4666:&lt;apk_repo_host&gt;:80 &lt;online-host&gt;</code></p> </li> </ol> <p>At this point the module can normally use <code>apk</code> with <code>ssh</code> on the offline host to install the desired packages</p> <p>Once the installation has finished, <code>gui.py</code> cleans the <code>/etc/hosts</code> file and the <code>iptables</code> rules from the offline host and closes the SSH tunnels.</p> <p>Note: when installing each package, <code>apk</code> verifies that it has been signed by the authors and maintainers of Alpine Linux. Therefore it is not necessary to trust the online host, but rather to initialise the APK keys in a trusted environment. For users of TowerOS, this means it is imperative to build the TowerOS images in a trusted environment and to manually verify the integrity of the keys.</p>"},{"location":"installation/","title":"Installation","text":"<p>To use TowerOS, you must first install the image for the thin client on the device you wish to use (normally a laptop):</p> <ol> <li>Download the latest image here: https://github.com/towercomputers/tower-tools/releases/latest.</li> <li>Prepare a bootable USB medium using the above image.</li> <li>Boot the thin client with the USB drive and follow the instructions.</li> </ol>"},{"location":"introduction/","title":"Introduction","text":"<p>TowerOS is an operating system for combining multiple, independent computers into a single high-assurance system for high-value targets and paranoid individuals. TowerOS is an example of a converged multi-level secure (MLS) computing system, similar to Qubes OS; but whereas Qubes OS takes a single computer and splits it into multiple security domains, TowerOS does the reverse---each security domain is regelated to a separate, dedicated Host (e.g. a Raspberry Pi), and the user accesses their applications from a Thin Client (e.g. a laptop) over a LAN using standard network protocols (namely, SSH and NX), with strict firewall rules governing all network communication. The different security domains are by default completely independent, and all communication across security boundaries is under the direct control of the user.</p> <p>In contrast to existing designs, Tower offers theoretically greater security guarantees, better usability, and more flexibility. The downside is that you need multiple computers to make it work. However, with the development of cheap, powerful and small single-board computers (SBCs), it's now quite practical to carry half a dozen computers with you wherever you go. For a more formal description of the design of TowerOS, including a detailed comparison with Qubes OS, please refer to the whitepaper.</p>"},{"location":"secure-boot/","title":"Secure Boot","text":"<p>Secure Boot is a security feature that is implemented in the BIOS and does not require special hardware. Secure Boot ensures that each component launched during the boot process is digitally signed, and that the signature is validated against a set of trusted certificates embedded in the UEFI BIOS.</p> <p>TowerOS offers the possibility to activate Secure Boot on the thin client. To do this, the firmware must be correctly configured before and after installation.</p>"},{"location":"secure-boot/#before-the-installation","title":"Before the installation","text":"<p>You must:</p> <ul> <li>Disable Secure Boot if necessary</li> <li>Reset to \"Setup Mode\"</li> <li>Clear all secure boot keys that have already been registered</li> </ul> <p>On ThinkPad firmware, these three things can be done on the same screen:</p> <p></p>"},{"location":"secure-boot/#after-the-installation","title":"After the installation","text":"<p>You must enable the \"Secure Boot\" feature on the same screen.</p> <p>Attention---once activated, you will not be able to boot from unsigned devices, for example a live system on an USB key. It will first be necessary to deactivate the Secure Boot feature.</p> <p>Remember to make a backup of the private keys used for Secure Boot, which are located here by default in <code>/usr/share/secureboot/keys/</code>.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#security-model","title":"Security Model","text":"<ul> <li>Direct communication between Hosts is forbidden.</li> <li>All communication between the Thin Client and a Host is over SSH and on port 22.</li> <li>All communication with a Host must originate with the Thin Client.</li> <li>All network connections between the Thin Client and a Host must be directly triggered by user action.</li> <li>SSH tunnels from the Thin Client or a Host through the Router are allowed.</li> </ul>"},{"location":"security/#trusted-computing-base","title":"Trusted Computing Base","text":"<ul> <li>TowerOS Tooling</li> <li>Alpine Linux Base System</li> <li>Network Drivers</li> <li>Network Card Hardware</li> <li>SSH</li> <li>NX (Screensharing)</li> </ul>"},{"location":"security/#threat-analysis","title":"Threat Analysis","text":"Class Attack Mitigated If so, how? Theft Theft of Device Yes Encrypted root disks Physical Tampering Evil-Maid Attack Optional Raspberry Pis: https://www.zymbit.com/ Physical Tampering Cold-Boot Attack Optional Raspberry Pis: https://www.zymbit.com/ Microarchitectural RowHammer; RowPress Yes Host-Isolation Microarchitectural Speculative Execution Yes Host-Isolation Physical Side-Channel Power Consumption (https://www.hertzbleed.com/) Optional Disable DVFS Physical Side-Channel Acoustic Emissions No Physical Side-Channel Electromagnetic Radiation No"},{"location":"usage/","title":"Usage","text":"<p>Hosts are divided into two types: online and offline. Online hosts live on a separate LAN from offline hosts, and the thin client is connected to both networks. One online host is deemed the \u201crouter\u201d, and the router is responsible for providing Internet access to the thin client and all other hosts. If you do not wish to maintain two separate networks, you can simply not provision any offline hosts.</p>"},{"location":"usage/#provisioning-hosts","title":"Provisioning Hosts","text":"<p>TowerOS provides tools for easily provisioning new hosts with the following steps, with the user guided through them by the <code>tower</code> CLI tool:</p> <ol> <li>Insert an SD card or USB key into the thin client.</li> <li>Call the <code>$ tower provision</code> command.</li> <li>Insert the SD card or USB key into the target host hardware.</li> <li>Turn on the host hardware.</li> <li>Wait for the provisioning process to complete on the thin client.</li> </ol> <p>NOTE: You must provision a router before you provision any other online hosts.</p>"},{"location":"usage/#provision-the-router","title":"Provision the Router","text":"<p>The first online host that you must provision is the router, which connect to the Internet via a WiFi network: </p> <pre><code>[thinclient]$ tower provision router \u2013wlan-ssid &lt;ssid&gt; \u2013wlan-password &lt;password&gt;\n</code></pre>"},{"location":"usage/#provision-an-online-host","title":"Provision an Online Host","text":"<p>Once the <code>router</code> is correctly provisioned, you may provision other online hosts:</p> <pre><code>[thinclient]$ tower provision &lt;host&gt; --online\n</code></pre>"},{"location":"usage/#provision-an-offline-host","title":"Provision an Offline Host","text":"<p>An offline host is a host without access to the Internet via the router.</p> <pre><code>[thinclient]$ tower provision &lt;host&gt; --offline\n</code></pre>"},{"location":"usage/#using-toweros","title":"Using TowerOS","text":"<p>Once your hosts are provisioned, you are ready to use TowerOS. You can of course access each host via SSH. However, you can also run GUI applications installed on a host such that the application appears to run on the thin client.</p>"},{"location":"usage/#execute-a-command-on-one-of-the-hosts","title":"Execute a command on one of the hosts:","text":"<p>Run a command on a host with SSH:</p> <pre><code>[thinclient]$ ssh &lt;host&gt; &lt;command&gt;\n</code></pre>"},{"location":"usage/#run-a-graphical-application-on-a-host-with-its-gui-appearing-on-the-thin-client","title":"Run a graphical application on a host, with its GUI appearing on the thin client:","text":"<pre><code>[thinclient]$ tower run &lt;host&gt; &lt;command&gt;\n</code></pre>"},{"location":"usage/#install-an-alpine-package-on-a-host","title":"Install an Alpine package on a host:","text":"<p>TowerOS makes it easy to install new packages on any host by tunneling a connection through the router:</p> <pre><code>[thinclient]$ tower install &lt;host&gt; &lt;package&gt;\n</code></pre>"},{"location":"usage/#list-your-hosts-and-their-statuses","title":"List your hosts and their statuses","text":"<pre><code>[thinclient]$ tower status\n</code></pre>"},{"location":"usage/#example-usage","title":"Example Usage","text":"<ol> <li>Provision the router:</li> </ol> <pre><code>[thinclient]$ tower provision router \u2013wlan-ssid &lt;ssid&gt; \u2013wlan-password &lt;password&gt;\n</code></pre> <ol> <li>Provision an offline host named <code>office</code>:</li> </ol> <pre><code>[thinclient]$ tower provision office\n</code></pre> <ol> <li>Install GCalculator on the <code>office</code> offline host:</li> </ol> <pre><code>[thinclient]$ tower install office galculator\n</code></pre> <ol> <li>Run galculator <code>office</code>:</li> </ol> <pre><code>[thinclient]$ startx\n[thinclient]$ tower run office gcalculator\n</code></pre>"}]}