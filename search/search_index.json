{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tower","text":"<p>Tower is a computer system for paranoid individuals and high-value targets that turns the existing paradigm for computer security on its head: Instead of taking a single computer and splitting it into multiple security domains at the level of the operating system or hypervisor (cf. AppArmor and QubesOS), Tower combines multiple, independent computers into a single, unified, virtual system with a shared, composited user interface. Each security domain is regelated to a separate, dedicated Host (e.g. a Raspberry Pi), and the user accesses their applications from a Thin Client (e.g. a laptop) over a LAN using standard network protocols (namely, SSH and NX), following strict firewall rules that govern all network communication.</p> <p>Technically speaking, Tower is an example of a converged multi-level secure (MLS) computing system. In contrast to existing designs, Tower offers theoretically greater security guarantees, better usability, and more flexibility. The downside, of course, is that you need multiple computers to make it work. But with the development of cheap, powerful and small single-board computers (SBCs), it's now quite practical to carry half a dozen computers with you wherever you go. So, instead of having to trust your operating system or hypervisor to be able properly to isolate different security domains all running on shared hardware, you can rely on standard, open-source implementations of widely used networking protocols, to connect multiple independent computers together to form a single, virtual device that functions very much like a normal desktop or laptop.</p> <p>This repository represents an OSS implementation of the above design. It includes within it tools for the following purposes:</p> <ol> <li>Provisioning and maintaining the Thin Client</li> <li>Provisioning, maintaining and monitoring the various Hosts</li> <li>Managing the network layer (provisioning the Switch, enforcing firewall rules, etc.)</li> </ol> <p>For a more formal description of the Tower architecture, including a comparison with Qubes OS, please refer to the whitepaper.</p>"},{"location":"DeveloperGuide/","title":"Development","text":""},{"location":"DeveloperGuide/#1-setup-environement","title":"1. Setup environement","text":"<p>To connect the Thin Client to internet you must:</p> <ol> <li>provision a <code>router</code></li> <li>set the thinclient gateway to <code>192.168.2.1</code> (the router`s ip):</li> </ol> <p>The file /etc/network/interfaces must contain the following:</p> <pre><code>auto lo\niface lo inet loopback\nauto eth0\niface eth0 inet static\n    address 192.168.2.100/24\n    gateway 192.168.2.1\nauto eth1\niface eth1 inet static\n    address 192.168.3.100/24\nEOF\n</code></pre> <ol> <li>set the DNS server:</li> </ol> <p>The file /etc/resolv.conf must contain the following:</p> <pre><code>nameserver 8.8.8.8\nnameserver 8.8.4.4\n</code></pre> <ol> <li>restart network with: <code>sudo rc-service networking restart</code></li> </ol> <p>Configure <code>git</code>, download Github repository in <code>~/towercomputers/tower-tools</code> and install <code>hatch</code> with:</p> <pre><code>$&gt; ~/install-dev.sh &lt;git-name&gt; &lt;git-email&gt; &lt;git-private-key-path&gt;\n</code></pre>"},{"location":"DeveloperGuide/#2-use-tower-with-hatch","title":"2. Use Tower with hatch","text":"<pre><code>$&gt; git clone git@github.com:towercomputers/tower-tools.git\n$&gt; cd tower-tools\n$&gt; pip install hatch\n$&gt; hatch run tower --help\n$&gt; hatch run build-tower-image --help\n</code></pre>"},{"location":"DeveloperGuide/#3-manually-qa-toweros-thinclient-release","title":"3. Manually QA TowerOS-ThinClient release","text":"<p>On first boot:</p> <ol> <li> <p>Basic checking</p> </li> <li> <p>Welcome message should be customized.</p> </li> <li>README, whitepaper and install-dev.sh should be in ~/.</li> <li>wheel package and host image should be in ~/.cache/tower/builds.</li> <li>iptables -L -v should show firewall rules and /var/logs/iptables.log should contain firewall logs.</li> <li> <p><code>lo</code> and <code>eth0</code> should be up (check  with <code>ip ad</code>)</p> </li> <li> <p>Provision an online host:</p> </li> </ol> <pre><code>$&gt; tower provision web --online --wlan-ssid &lt;ssid&gt; --wlan-password &lt;password&gt; --sd-card /dev/sdb \n</code></pre> <ol> <li>Provision an offline host:</li> </ol> <pre><code>$&gt; tower provision office --offline --sd-card /dev/sdb\n</code></pre> <ol> <li>Check status:</li> </ol> <pre><code>$&gt; tower status\n</code></pre> <ol> <li>Install package in offline host:</li> </ol> <pre><code>$&gt; tower install office xcalc --online-host office\n</code></pre> <ol> <li>Install package in online host:</li> </ol> <pre><code>$&gt; tower install web midori\n</code></pre> <ol> <li>Test installed packages</li> </ol> <pre><code>$&gt; startx\n$&gt; tower run office xcalc\n$&gt; tower run web midori\n</code></pre> <p>Check also if the Application menu contains shortcuts for installed packages.</p> <ol> <li> <p>Logout from <code>xfce</code> and connect to internet as explained above</p> </li> <li> <p>Build an host image with:</p> </li> </ol> <pre><code>$&gt; buld-tower-image host\n</code></pre> <ol> <li>Build a thinclient image with:</li> </ol> <pre><code>$&gt; buld-tower-image thinclient\n</code></pre> <ol> <li>Install development environment with:</li> </ol> <pre><code>$&gt; ~/install-dev.sh &lt;git-name&gt; &lt;git-email&gt; &lt;git-private-key-path&gt;\n</code></pre> <ol> <li>If you are brave redo all these tests with the image generated in step 10 :)</li> </ol>"},{"location":"DeveloperGuide/#4-build-you-own-custom-thin-client-linux","title":"4. Build you own custom Thin Client (Linux)","text":""},{"location":"DeveloperGuide/#41-install-dependencies","title":"4.1. Install dependencies","text":"<pre><code>$&gt; apk add alpine-base coreutils python3 py3-pip py3-rich sudo openssh dhcpcd avahi \\\n      avahi-tools wpa_supplicant rsync git iptables rsync lsblk perl-utils xz \\\n      musl-locales e2fsprogs-extra nx-libs xsetroot mcookie parted lsscsi figlet \\\n      alpine-sdk build-base apk-tools acct acct-openrc alpine-conf sfdisk busybox \\\n      fakeroot syslinux xorriso squashfs-tools mtools dosfstools grub-efi abuild \\\n      agetty runuser nano vim net-tools losetup xorg-server xf86-input-libinput \\\n      xinit udev xfce4 xfce4-terminal xfce4-screensaver adw-gtk3 \\\n      adwaita-xfce-icon-theme setxkbmap\n</code></pre>"},{"location":"DeveloperGuide/#42-enable-services","title":"4.2. Enable services","text":"<p>If necessary, enable IPv4 with:</p> <pre><code>sed -i 's/noipv4ll/#noipv4ll/' /etc/dhcpcd.conf\n</code></pre> <p>then</p> <pre><code>$&gt; rc-update add dhcpcd\n$&gt; rc-update add avahi-daemon\n$&gt; rc-update add iptables\n$&gt; rc-update add networking\n$&gt; rc-update add wpa_supplicant boot\n$&gt; rc-update add dbus\n</code></pre> <p>Important: Make sure you are connected to the switch and check that your first wired interface (starting with the letter <code>e</code>) has an assigned IP.</p>"},{"location":"DeveloperGuide/#43-update-etcsudoers-and-groups","title":"4.3. Update <code>/etc/sudoers</code> and groups","text":"<p><code>tower-tools</code> assumes that the current user has full <code>sudo</code> access, with no password. (Please refer to our threat model.) Check if /etc/sudoers contains the following line:</p> <pre><code>&lt;you_username&gt; ALL=(ALL) NOPASSWD: ALL\n</code></pre> <p>To build an image with <code>build-tower-image</code> you need to add the current user in the <code>abuild</code> group:</p> <pre><code>addgroup &lt;you_username&gt; abuild\n</code></pre>"},{"location":"DeveloperGuide/#44-install-tower-tools","title":"4.4. Install <code>tower-tools</code>","text":"<p>Update pip to the latest version:</p> <pre><code>$&gt; python3 -m pip install --upgrade pip\n</code></pre> <p>then:</p> <pre><code>$&gt; python3 -m pip install \"tower-tools @ git+ssh://github.com/towercomputers/tower-tools.git\"\n</code></pre>"},{"location":"DeveloperGuide/#5-generate-an-host-image-with-build-image","title":"5. Generate an host image with build-image","text":"<pre><code>$&gt; build-tower-image host\n</code></pre> <p>This will generate an image file compressed with xz in <code>~/.cache/tower/builds/</code>. Images in this folder will be used by default by the provision command if the <code>--image</code> flag is not provided.</p>"},{"location":"DeveloperGuide/#6-build-a-toweros-image-with-docker","title":"6. Build a TowerOS image with Docker","text":"<p>Build the Docker image with:</p> <pre><code>$&gt; git clone git@github.com:towercomputers/tower-tools.git\n$&gt; cd tools\n$&gt; hatch build -t wheel\n$&gt; docker build -t build-tower-image:latest .\n</code></pre> <p>Then build the TowerOS image inside a Docker container:</p> <pre><code>$&gt; docker run --name towerbuilder --user tower --privileged -v /dev:/dev build-tower-image thinclient\n</code></pre> <p>Retrieve that image from the container:</p> <pre><code>$&gt; docker cp towerbuilder:/home/tower/.cache/tower/builds/toweros-thinclient-0.0.1-20230513171731-x86_64.iso ./\n</code></pre> <p>Finally delete the container with:</p> <pre><code>$&gt; docker rm towerbuilder\n</code></pre> <p>Note: With the ARM64 architecture, you must use <code>buildx</code> and a cross-platform emulator like <code>tonistiigi/binfmt</code>.</p> <pre><code>$&gt; docker buildx create --use\n$&gt; docker buildx build -t build-tower-image:latest --platform=linux/amd64 --output type=docker .\n$&gt; docker run --privileged --rm tonistiigi/binfmt --install all\n$&gt; docker run --platform=linux/amd64 --name towerbuilder --user tower --privileged -v /dev:/dev \\\n              build-tower-image thinclient\n</code></pre>"},{"location":"SecureBoot/","title":"Secure Boot","text":"<p>Secure Boot is a server security feature that is implemented in the BIOS and does not require special hardware. Secure Boot ensures that each component launched during the boot process is digitally signed and that the signature is validated against a set of trusted certificates embedded in the UEFI BIOS.</p> <p>Tower OS-Thin Client offers the possibility to activate Secure Boot. To do this, the firmware must be correctly configured before and after installation.</p>"},{"location":"SecureBoot/#before-the-installation","title":"Before the installation","text":"<p>You must:</p> <ul> <li>disable Secure Boot if necessary</li> <li>Reset to \"Setup Mode\"</li> <li>Clear all secure boot keys already registered.</li> </ul> <p>On Thinkpad firmware these three things can be done on the same screen:</p> <p></p>"},{"location":"SecureBoot/#after-the-installation","title":"After the installation","text":"<p>You must enable the \"Secure Boot\" in the same screen.</p> <p>Attention, once activated you will not be able to boot on unsigned devices, for example a live system on a USB key. It will first be necessary to deactivate the \"Secure Boot\".</p> <p>Remember to make a backup of the private keys used for Secure Boot. They are located here: /usr/share/secureboot/keys/</p>"},{"location":"hardware/","title":"Hardware requirements","text":"<p>To use Tower you need a Thin Client and several Hosts connected via one or ideally two switches.</p> <p>The Thin Client is typically a laptop like the Lenovo X270. An SD-card reader is necessary for the Thin Client to prepare the SD-cards containing the hosts' OS. Two RJ45 ports are also necessary to connect the Thin Client to the two switches (you can optionally use a USB ethernet adapter).</p> <p>For the moment tower has been tested with two types of hosts: Raspberry PI 4b and Compute Module 4 Lite.</p>"},{"location":"hardware/#1-raspberry-pi-4b","title":"1. Raspberry PI 4b","text":"<p>For each Raspberry PI you need:</p> <ul> <li>an SD card, for the boot partition</li> <li>a USB key which will serve as a hard drive.</li> <li>for offline hosts a Real Time Clock hat</li> </ul> <p>Tips:</p> <ul> <li>Remember to plug the USB key into the blue port (USB 3.0)</li> <li>For hosts that serve as a router we recommend an RPI with 2GB of RAM, for others, especially if you plan to run graphicals applications, we recommend 8GB of RAM.</li> <li>for sd-cards and usb keys, look at the list of hardware that we tested and their performance (TODO)</li> </ul>"},{"location":"hardware/#2-compute-module-4-lite","title":"2. Compute Module 4 Lite","text":"<p>Using CM4s and the Deskpi Super6c board you can avoid most cables and put all your hosts in an ATX case.</p> <p>For each CM4 you need:</p> <ul> <li>an SD card, for the boot partition</li> <li>a NVMe M.2 SS2 which will serve as a hard drive.</li> </ul> <p>One of the CM4s, the one that will serve as a router, must have WiFi and 2GB of RAM is sufficient. For other hosts, WiFi is not necessary, but we recommend 8GB of RAM, especially for hosts that need to run graphicals applications.</p> <p>Ideally you should use two Deskpis, one for online hosts and another for offline hosts.</p>"},{"location":"implementation/","title":"Implementation","text":"<p>To date, <code>tower-tools</code> includes six main modules: <code>buildthinclient.py</code> and <code>buildhost.py</code> to build the OS images used by the <code>thinclient</code> and the hosts. <code>sshconf.py</code> which manages <code>tower-tools</code> and <code>ssh</code> configuration files. <code>provision.py</code>, <code>install.py</code>, and <code>gui.py</code> which respectively allow you to provision a host, to install an application on it even without an internet connection and to run a graphical application of a host from the <code>thinclient</code>.</p>"},{"location":"implementation/#1-network-architecture","title":"1. Network architecture","text":"<p>The thinclient is connected to two separate networks (via two distinct switches), one connected to the internet, the other offline. The hosts supposed to have a connection are connected to the first network, and those which should be offline are connected to the second. On the online network, one of the hosts, called the <code>router</code>, is connected to the internet and shares the connection with all the hosts connected to the same network. All IPs are static and assigned by the <code>tower</code> tool. Here are the IPs used:</p> <ul> <li>TOWER_NETWORK_ONLINE = \"192.168.2.0/24\"</li> <li>TOWER_NETWORK_OFFLINE = \"192.168.3.0/24\"</li> <li>THIN_CLIENT_IP_ETH0 = \"192.168.2.100\"</li> <li>THIN_CLIENT_IP_ETH1 = \"192.168.3.100\"</li> <li>ROUTER_IP = \"192.168.2.1\"</li> <li>FIRST_HOST_IP = 200 # 192.168.2.200 or 192.168.3.200</li> </ul>"},{"location":"implementation/#2-firewall-rules","title":"2. Firewall Rules","text":"<p>The firewall is the most important element for securing the Tower network. <code>iptables</code> is installed and configured on each host and on the thinclient using the following two scripts:</p> <p>https://github.com/towercomputers/tools/blob/dev/scripts/toweros-host/installer/configure-firewall.sh https://github.com/towercomputers/tools/blob/dev/scripts/toweros-thinclient/installer/configure-firewall.sh</p> <p>Both are standalone, ie they clean all the rules at the beginning and save the new rules at the end.</p> <p>The thinclient is configured with the following guide https://wiki.archlinux.org/title/Simple_stateful_firewall Hosts are configured the same way, but with the following additional rules:</p> <ul> <li>Port 22 is open only for the Thin Client (for <code>ssh</code> connections)</li> <li>for offline hosts we reject all outgoing traffic</li> <li>for online hosts, outgoing traffic is only rejected to the thinclient and the other hosts.</li> <li>for the host having the role of <code>router</code>, we activate the ip forwarding to share the connection with the other online hosts.</li> </ul>"},{"location":"implementation/#3-toweros-thinclient","title":"3. TowerOS-ThinClient","text":"<p><code>buildthinclient.py</code> is the module responsible for generating an image of TowerOS with the <code>build-tower-image thinclient</code> command.</p> <p>TowerOS is based on Alpine Linux, and <code>buildthinclient.py</code> uses the <code>mkimage</code> tool (see https://wiki.alpinelinux.org/wiki/How_to_make_a_custom_ISO_image_with_mkimage).</p> <p>The installer contains all the apk and pip packages necessary for installing the base system and <code>tower-tools</code>, which is ready to use from the first boot. In this way, the installation of the system, as well as the provisioning of a first host, does not require an Internet connection.</p> <p>Here are the different steps taken by <code>buildthinclient.py</code> to generate an image:</p> <ol> <li> <p>Gathering the necessary builds. The script starts by checking for the existence of a <code>./dist</code>, <code>./builds</code> or <code>~/.cache/tower/builds/</code> folder. If one of them exists, this is where the script will fetch the builds and place the final image. If no folder exists, then the script creates the folder <code>~/.cache/tower/builds/</code>. Next:</p> <ol> <li>The script then verifies that the TowerOS-Host image is present. If not, it launches the build of a new image (cf. TowerOS-Host). </li> <li>The script checks for the existence of a <code>tower-tools</code> wheel package. If it does not exist the package is retrieved from Github.</li> </ol> </li> <li> <p>Downloading pip packages with <code>pip download</code> in a cache folder</p> </li> <li> <p>Creating and updating an Alpine APK overlay folder with mainly:</p> <ol> <li><code>pip</code> cache folder</li> <li>add  system install bash scripts (see https://github.com/towercomputers/tower-tools/tree/dev/scripts/toweros-thinclient)</li> <li>add the Towercomputers documentation</li> <li>Add /etc configuration files</li> <li>add builds required by <code>tower-tools</code> (TowerOS-Host, <code>tower-tools</code>)</li> </ol> </li> <li> <p>Launch of <code>mkimage</code> which takes care of the rest.</p> </li> <li> <p>Renaming and copying the image into the <code>builds</code> folder.</p> </li> <li> <p>Cleaning temporary files.</p> </li> </ol> <p>Notes about the TowerOS-ThinClient installer:</p> <ul> <li>The TowerOS-ThinClient install scripts generally follow the official Alpine Linux install guide (see https://wiki.alpinelinux.org/wiki/Installation) </li> <li>The installer sets up an <code>iptables</code> firewall as described here https://wiki.archlinux.org/title/Simple_stateful_firewall.</li> <li>TowerOS-ThinClient uses <code>Syslinux</code> as the boot loader.</li> </ul>"},{"location":"implementation/#4-toweros-host","title":"4. TowerOS-Host","text":"<p><code>buildhost.py</code> is the module responsible for generating an image of TowerOS-ThinClient when the <code>build-tower-image host</code> command is executed and also for configuring the image when the <code>tower provision</code> command is called.</p> <p><code>buildhost.py</code> uses the same method as <code>pigen</code> to build an image for a Raspberry PI (see https://github.com/RPi-Distro/pi-gen/blob/master/export-image/prerun.sh) but unlike <code>pigen</code> which uses a Debian-based system, <code>buildhost.py</code> uses an Alpine Linux-based system (see https://wiki.alpinelinux.org/wiki/Classic_install_or_sys_mode_on_Raspberry_Pi).</p> <p>TowerOS-ThinClient must be used with the <code>tower provision</code> command which finalises the configuration of the image which is otherwise neither secure (no firewall in particular) nor ready to be used by <code>tower-tools</code>.</p> <p>Here are the different steps taken by <code>buildhost.py</code> to generate an image:</p> <ol> <li> <p>Installing an Alpine Linux system in a mounted temporary folder:</p> <ol> <li>creating an image file with <code>mkfs.ext4</code></li> <li>mount this image with <code>mount</code></li> <li>installation of a minimalist Alpine Linux system and NX in the mounted folder (https://dl-cdn.alpinelinux.org/alpine/v3.17/releases/armv7/alpine-rpi-3.17.3-armv7.tar.gz)</li> </ol> </li> <li> <p>creation with <code>parted</code>, in an image file, of the partitions necessary for a Raspberry PI with the size adapted for the system installed in step 1.</p> </li> <li> <p>copy, with <code>rsync</code>, the system installed in step 1 into the partitions created in step 2.</p> </li> <li> <p>compression of the image containing the partitions from step 2.</p> </li> <li> <p>Unmounting and cleaning files and temporary folders.</p> </li> </ol> <p>Here are the different steps taken by <code>buildhost.py</code> to configure an image when provisioning an host:</p> <ol> <li> <p>copy image to sd-card</p> </li> <li> <p>expand root partition to occupy entire sd-card</p> </li> <li> <p>places a <code>tower.env</code> file in the root of the boot partition. This file contains all the variables needed to install the system on first boot (HOSTNAME, USERNAME, PUBLIC_KEY, ...).</p> </li> <li> <p>unmount the sd-card which is ready to be inserted into the RPI</p> </li> </ol> <p>Note: A TowerOS-ThinClient image is placed in the <code>~/.cache/tower/builds/</code> folder by the TowerOS installer.</p>"},{"location":"implementation/#5-sshconf","title":"5. SSHConf","text":"<p><code>tower-tools</code> uses a single configuration file in the same format as an SSH config file: <code>~/.ssh/tower.conf</code>. This file, included in <code>~/.ssh/config</code>, is used both by <code>tower-tools</code> to maintain the list of hosts and by <code>ssh</code> to access hosts directly with <code>ssh &lt;host&gt;</code>. <code>sshconf.py</code> is responsible for maintaining this file and generally anything that requires manipulation of something in the <code>~./ssh</code> folder. Notably:</p> <ol> <li>to discover the IP of a newly installed host and update <code>tower.conf</code></li> <li>update <code>~/.ssh/know_hosts</code></li> <li>check the status of a host and if he is online.</li> </ol> <p>Note: <code>sshconf.py</code> uses https://pypi.org/project/sshconf/ to manipulate <code>ssh</code> config files.</p>"},{"location":"implementation/#6-provision","title":"6. Provision","text":"<p><code>provision.py</code> is used by the <code>tower provision &lt;host&gt;</code> command to prepare an SD card directly usable by a Rasbperry PI.</p> <p>The steps to provision a host are as follows:</p> <ol> <li>generation of a key pair.</li> <li>generation of the host configuration (<code>tower.env</code> file), with the values provided on the command line, or with those retrieved from the <code>thinclient</code>.</li> <li>copy of the TowerOS-ThinClient image on the SD card and insertion of the configuration file.</li> <li>waiting for the new host to be detected on the network after the user inserts the sd-card in the RPI and the boot is finished.</li> <li>updated <code>ssh</code> and <code>tower-tools</code> configuration file.</li> </ol> <p>Once a host is provisioned it is therefore directly accessible by ssh with <code>ssh &lt;host&gt;</code> or <code>tower run &lt;host&gt;</code>.</p>"},{"location":"implementation/#7-gui","title":"7. GUI","text":"<p>GUI is a module that allows the use of the NX protocol through an SSH tunnel. It allows to execute from the <code>thinclient</code> a graphical application installed on one of the hosts with <code>tower run &lt;host&gt; &lt;application-name&gt;application&gt;</code>.</p> <p><code>nxagent</code> must be installed in the host and <code>nxproxy</code> in the <code>thinclient</code>. Of course both are pre-installed in TowerOS and TowerOS-ThinClient.</p> <p>Here are the steps taken by <code>gui.py</code> to run an application on one of the hosts:</p> <ol> <li> <p>Generation of a unique cookie which is added in the host with <code>xauth add</code>.</p> </li> <li> <p>With <code>ssh</code> launch <code>nxagent</code> on the host which only accepts local connections.</p> </li> <li> <p>With the same command line, open a tunnel between the host and the <code>thinclient</code> on the port of <code>nxagent</code>.</p> </li> <li> <p>Launch <code>nxproxy</code> with the cookie generated in step 1 and on the same port as the tunnel opened in step 3.</p> </li> <li> <p>At this stage <code>nxproxy</code> and <code>nxagent</code> are connected and we have a \"virtual screen\" on which we run the graphical application with: <code>ssh &lt;host&gt; DISPLAY=:50 &lt;application-name&gt;application&gt;</code>.</p> </li> <li> <p>When the application launched in the previous step is closed, <code>gui.py</code></p> <ol> <li>closes <code>nxagent</code> and the tunnel opened in step 2 and 3.</li> <li>revokes the cookie from step 1 with <code>xauth remove</code></li> <li>closes <code>nxproxy</code></li> </ol> </li> </ol> <p>GUI works the same way as X2GO from which it is directly inspired.</p>"},{"location":"implementation/#8-install","title":"8. Install","text":"<p>This module allows to use <code>apk</code> on an offline host through an <code>ssh</code> tunnel to an online host. To do this it performs the following steps:</p> <ol> <li> <p>Preparing the offline host to redirect requests to the <code>apk</code> repository to the <code>thinclient</code>:</p> <ol> <li>Added a <code>127.0.0.1 &lt;apk_repo_host&gt;</code> entry in the <code>/etc/hosts</code> file</li> <li>Added an <code>iptables</code> rule to redirect requests on port 80 to port 4443 (so you don't need to open the tunnel in <code>root</code> because port 80 is protected).</li> <li>Preparation of a pacman.conf file containing only the <code>apk_repo_host</code>.</li> <li>Opening a tunnel to redirect port 4443 of the offline host to port 4666 of the <code>thinclient</code>.</li> </ol> </li> <li> <p>Open a tunnel to redirect port 4666 from <code>thinclient</code> to the apk repository host on the online host with: <code>ssh -R 4666:&lt;apk_repo_host&gt;:80 &lt;online-host&gt;</code>.</p> </li> <li> <p>At this point the module can normally use <code>apk</code> with <code>ssh</code> on the offline host to install the desired packages.</p> </li> <li> <p>Once the installation is finished, clean the <code>/etc/hosts</code> file and the <code>iptables</code> rules on the offline host and close the ssh tunnels.</p> </li> </ol> <p>Note: when installing each package, <code>apk</code> verifies that it has been signed by the authors and maintainers of Alpine Linux. Therefore it is not necessary to trust the online host but above all to initialise the apk keys in a trusted environment. This means for us that it is imperative to build the images of TowerOS and TowerOS-ThinClient in a trusted environment and to manually verify the keys.</p>"},{"location":"installation/","title":"Installation","text":"<p>To use Tower you need to run the TowerOS-ThinClient GNU/Linux distribution (based on Alpine Linux) on your Thin Client.</p> <p>To install TowerOS-ThinClient:</p> <ol> <li>Download the latest image here: https://github.com/towercomputers/tower-tools/releases/latest.</li> <li>Prepare a bootable USB medium using the above image.</li> <li>Boot the Thin Client with the USB drive and follow the instructions.</li> </ol>"},{"location":"security/","title":"Security","text":""},{"location":"security/#1-security-guarantees","title":"1. Security Guarantees","text":""},{"location":"security/#11-firewall","title":"1.1 Firewall","text":"<ul> <li>There is zero direct communication between hosts (however there is tunneling for package management).</li> <li>All communication between the thin client and a host is over SSH and on port 22 (ideally including screen sharing).</li> <li>All communication between the thin client and a host must originate with the thin client.</li> <li>No connections to the online hosts may originate from the Internet.</li> <li>Tunneling from the thin client to the Internet is allowed.</li> </ul>"},{"location":"security/#12-hardware","title":"1.2 Hardware","text":"<ul> <li>Online hosts are connected to an Ethernet switch and a WLAN; offline hosts are connected only to the switch.</li> </ul>"},{"location":"security/#2-operating-system","title":"2. Operating System","text":"<ul> <li>Reasonable standards; but this is mostly out of scope. (Disable HT; use a hardened Linux kernel; etc.)</li> </ul>"},{"location":"security/#21-application-level","title":"2.1. Application-Level","text":"<ul> <li>All network connections between the thin client and a host) must be directly triggered by user action.</li> </ul>"},{"location":"security/#3-trusted-computing-base","title":"3. Trusted Computing Base","text":"<ul> <li>Tower Tooling</li> <li>Alpine Linux Base System</li> <li>Network Drivers</li> <li>Network Card Hardware</li> <li>SSH</li> <li>Screensharing Software</li> </ul>"},{"location":"security/#4-threat-analysis","title":"4. Threat Analysis","text":"Class Attack Mitigated If so, how? Theft Theft of Device Yes Encrypted root disks Physical Tampering Evil-Maid Attack Optional Raspberry Pis: https://www.zymbit.com/ Physical Tampering Cold-Boot Attack Optional Raspberry Pis: https://www.zymbit.com/ Microarchitectural RowHammer; RowPress Yes Host-Isolation Microarchitectural Speculative Execution Yes Host-Isolation Physical Side-Channel Power Consumption (https://www.hertzbleed.com/) Optional Disable DVFS Physical Side-Channel Acoustic Emissions No Physical Side-Channel Electromagnetic Radiation No"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#1-provision-a-host","title":"1. Provision a host","text":"<p>Prepare the sd-card in the Thin Client with the command bellow. Once the sd-card is ready you must insert it into the Raspberry Pi or CM4 and turn it on.</p> <pre><code>$&gt; tower provision &lt;host&gt; --offline\n</code></pre> <p>or, for an online host:</p> <pre><code>$&gt; tower provision &lt;host&gt; --online\n</code></pre> <p>Keyboard, timezone and WiFi parameters are retrieved from the Thin Client. You can customize them with the appropriate argument (see <code>tower provision --help</code>).</p>"},{"location":"usage/#2-execute-a-command-on-one-of-the-hosts","title":"2. Execute a command on one of the hosts","text":"<p>Run a command on a host with SSH:</p> <pre><code>$&gt; ssh &lt;host&gt; ls ~/\n</code></pre> <p>or a graphical application with NX protocol:</p> <pre><code>$&gt; tower run &lt;host&gt; &lt;application-name&gt;\n</code></pre>"},{"location":"usage/#3-install-an-application-on-one-of-the-hosts","title":"3. Install an application on one of the hosts","text":"<pre><code>$&gt; tower install &lt;host&gt; &lt;application-name&gt;\n</code></pre> <p>or, if the host is offline, you can tunnel the installation through an online host:</p> <pre><code>$&gt; tower install &lt;offline-host&gt; &lt;application-name&gt; --online-host &lt;online-host&gt; \n</code></pre>"},{"location":"usage/#4-list-hosts-and-their-statuses","title":"4. List hosts and their statuses","text":"<pre><code>$&gt; tower status\n</code></pre>"},{"location":"usage/#5-example-using-two-hosts","title":"5. Example using two hosts","text":"<p>Provision the first offline host named <code>office</code>.</p> <pre><code>$&gt; tower provision office\n</code></pre> <p>Provision a second online host named <code>web</code>.</p> <pre><code>$&gt; tower provision web --online \u2013wlan-ssid &lt;ssid&gt; \u2013wlan-password &lt;password&gt;\n</code></pre> <p>Install galculator on the <code>office</code> offline host.</p> <pre><code>$&gt; tower install office galculator --online-host=web\n</code></pre> <p>Run galculator from <code>office</code>.</p> <pre><code>$&gt; startx\n$&gt; tower run office gcalculator\n</code></pre>"}]}